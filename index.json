[{"content":"Prerequisites Create an account on https://auth0.com/signup with a free plan\nNavigate to \u0026ldquo;Applications -\u0026gt; Applications\u0026rdquo; to see your \u0026ldquo;Default App\u0026rdquo;. Grab the \u0026ldquo;Client ID\u0026rdquo;, \u0026ldquo;Client Secret\u0026rdquo; and \u0026ldquo;Domain\u0026rdquo; from \u0026ldquo;Settings\u0026rdquo; page of Default App\nNavigate to \u0026ldquo;Applications -\u0026gt; Applications -\u0026gt; Default App -\u0026gt; API\u0026rdquo;\nCheck Auth0 Management API checkbox to access management API using this app credentials Click on the drop down to select the scopes/permissions for this app and select read:users, update:users, read:roles scopes. These will be required later to assign roles users after they complete a sign up Create a new API application on Auth0 : \u0026ldquo;Applications -\u0026gt; API -\u0026gt; Create API\u0026rdquo;\nName: \u0026lt;Provide a friendly name for the API\u0026gt; (Example: \u0026ldquo;sample-api\u0026rdquo;) Identifier: \u0026lt;A unique identifer name for your API endpoints\u0026gt; (This will be the audience in the issued token) (Example: \u0026ldquo;https://api.example.com\u0026rdquo;) JWT Signing algorithm: RS256 Create permissions for your API: Applications -\u0026gt; API -\u0026gt; \u0026lt;your_API_app\u0026gt; -\u0026gt; Permissions\nUse \u0026ldquo;Add a permission\u0026rdquo; to add any number of permissions that you wish to use for all your endpoints. For this example: Permission: \u0026ldquo;read:messages\u0026rdquo; Description: \u0026ldquo;Read messages from a private endpoint with scope\u0026rdquo; These permissions can either be granted to the web app (Tokens created using client credentials) OR to web app users using \u0026ldquo;Roles\u0026rdquo; and RBAC controls in Auth0 Go to settings of the API created and check \u0026ldquo;Enable RBAC\u0026rdquo; box and \u0026ldquo;Add permissions in the access token\u0026rdquo; box. This allows access token to apply RBAC rules and inject required scopes into the token\nNavigate to \u0026ldquo;Applications -\u0026gt; Applications -\u0026gt; Default App -\u0026gt; APIs\u0026rdquo; and perform the following actions:\nTurn on authorization for \u0026ldquo;sample-api\u0026rdquo; Expand the dropdown to select granular permissions read:messages These are general set of scopes to be used by the entire webapp (Default app). An access token created using the webapp\u0026rsquo;s client credentials will receive an access token with read:messages NOTE: A user using this webapp that has authorization for this API will not receive this permission by default. If a user logs in to the webapp using consent screen, their access token will not have this permission by default. You have to create \u0026ldquo;Role\u0026rdquo; and enable RBAC controls to generate user access tokens with these permissions Optional user scope management For a production webapp, you would ideally: Create a Role (User management -\u0026gt; Roles) Make a note of the \u0026ldquo;Role ID\u0026rdquo; displayed below the name of the Role Click \u0026ldquo;Permissions -\u0026gt; Add permissions \u0026quot; for the created role Select permissions from existing APIs (For example: Selecting \u0026ldquo;sample-api\u0026rdquo; will show you \u0026ldquo;read:messages\u0026rdquo; as an available permission) and click \u0026ldquo;Add permissions\u0026rdquo; Click \u0026ldquo;Actions -\u0026gt; Triggers -\u0026gt; post-user-registration\u0026rdquo; (triggers after a new user has been created in the database.) \u0026ldquo;Add action -\u0026gt; + -\u0026gt; Build from scratch\u0026rdquo; Name: \u0026ldquo;Assign roles to users after signup\u0026rdquo; Trigger: \u0026ldquo;Post User Registration\u0026rdquo; Create Add the following secrets on the left side panel for the script to use clientId (Client ID of your Default App) clientSecret (Client secret of your Default App) domain (Domain name of your Auth0 tenant account) user_role_id (The role id you want to assign all signed up users) Add the following script that creates a management client instance and updates the roles of a user exports.onExecutePostUserRegistration = async (event, api) =\u0026gt; { const ManagementClient = require(\u0026#39;auth0\u0026#39;).ManagementClient; // Initialize the Management Client const management = new ManagementClient({ domain: event.secrets.domain, clientId: event.secrets.clientId, clientSecret: event.secrets.clientSecret, scope: \u0026#39;read:users update:users read:roles\u0026#39; }); const userId = event.user.user_id; const roleId = event.secrets.user_role_id; try { // Get the user\u0026#39;s current roles const userRoles = await management.getUserRoles({ id: userId }); // Check if the user already has the \u0026#34;User\u0026#34; role const hasUserRole = userRoles.some(role =\u0026gt; role.id === roleId); if (!hasUserRole) { // Assign the \u0026#34;User\u0026#34; role to the user await management.assignRolestoUser({ id: userId }, { roles: [roleId] }); console.log(`Assigned \u0026#34;User\u0026#34; role to user ${userId}`); } } catch (e) { console.error(\u0026#39;Error assigning role:\u0026#39;, e); } }; This will ensure that every user that signs up will have the Role attached to them and hence the permissions that come with the role. This will add the role\u0026rsquo;s permissions/scopes to the access tokens issued to the user after they login. Verify access to API using audience Now that your Default App has authorization to use your newly created API, lets test it out. Get your Client ID, client secret and domain from the Settings page of your \u0026ldquo;Default App\u0026rdquo; Send a curl request to verify if we get back an access token with \u0026ldquo;sample-api\u0026rdquo; identifier as audience Export webapp details as environment variables export CLIENT_ID= \u0026lt;DEFAULT_APP_CLIENT_ID\u0026gt; export CLIENT_SECRET= \u0026lt;DEFAULT_APP_CLIENT_SECRET\u0026gt; export DOMAIN= \u0026lt;DEFAULT_APP_DOMAIN\u0026gt; Curl request curl --request POST \\ --url \u0026#34;https://$DOMAIN/oauth/token\u0026#34; \\ --header \u0026#39;content-type: application/json\u0026#39; \\ --data @- \u0026lt;\u0026lt; EOF | jq { \u0026#34;client_id\u0026#34;:\u0026#34;$CLIENT_ID\u0026#34;, \u0026#34;client_secret\u0026#34;:\u0026#34;$CLIENT_SECRET\u0026#34;, \u0026#34;audience\u0026#34;:\u0026#34;https://api.example.com\u0026#34;, \u0026#34;grant_type\u0026#34;:\u0026#34;client_credentials\u0026#34; } EOF Response { \u0026#34;access_token\u0026#34;: \u0026#34;eyJhbGciOiJSUzI1NiIsInR5cCI...\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;read:messages\u0026#34;, \u0026#34;expires_in\u0026#34;: 86400, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34; } export ACCESS_TOKEN=\u0026#34;eyJhbGciOiJSUzI1NiIsInR5cCI...\u0026#34; Display the contents of access token payload to check if the right audience and scopes are injected $ echo $ACCESS_TOKEN | cut -d \u0026#39;.\u0026#39; -f2 | base64 -d |jq { \u0026#34;iss\u0026#34;: \u0026#34;\u0026lt;YOUR_DOMAIN_NAME\u0026gt;\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;XStySocTNNAJkwa7kTNNGqrwYpHmueq7@clients\u0026#34;, \u0026#34;aud\u0026#34;: \u0026#34;https://api.example.com\u0026#34;, \u0026#34;iat\u0026#34;: 1744935715, \u0026#34;exp\u0026#34;: 1745022115, \u0026#34;scope\u0026#34;: \u0026#34;read:messages\u0026#34;, \u0026#34;gty\u0026#34;: \u0026#34;client-credentials\u0026#34;, \u0026#34;azp\u0026#34;: \u0026#34;XStySocTNNAJkwa7kTNNGqrwYpHmueq7\u0026#34;, \u0026#34;permissions\u0026#34;: [ \u0026#34;read:messages\u0026#34; ] } Protect your webapp backend API endpoints Create a simple FastAPI backend server Create a .env file and store Auth0 domain and Auth0 API audience value for the backend server to validate incoming bearer tokens Example: $ cat .env AUTH0_DOMAIN=dev-s6oegu3u80a0upg4.us.auth0.com API_AUDIENCE=https://api.example.com Create 3 API endpoints /public - Returns a 200 OK success response without any authentication /private - Returns a 200 OK success response with a valid bearer token (no scope requiredment). Error otherwise /private/scoped - Returns a 200 OK success response with a valid bearer token and a valid scope. Error otherwise Sample server Create a new directory for sample server backend\nmkdir auth0-fastapi-api-protection; cd auth0-fastapi-api-protection Create a virtual environment to install dependencies using uv\npip install uv uvicorn; uv venv .venv Create a requirements.txt to list the dependencies to install\nrequirements.txt fastapi uvicorn[standard] python-jose[cryptography] requests jwt Install dependencies using uv\nsource .venv/bin/activate; uv pip install -r requirements.txt Create a server.py file with the following contents\nfrom fastapi import FastAPI, Depends, HTTPException, status, Security from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials, SecurityScopes from fastapi.responses import JSONResponse from jose import jwt, JWTError, ExpiredSignatureError from typing import Dict, Any import requests import os from dotenv import load_dotenv from pydantic import BaseModel from functools import lru_cache import logging from datetime import datetime, timezone # Configure logging logging.basicConfig(level=logging.INFO) logger = logging.getLogger(__name__) # Load environment variables load_dotenv() # Environment variables AUTH0_DOMAIN = os.getenv(\u0026#34;AUTH0_DOMAIN\u0026#34;) API_AUDIENCE = os.getenv(\u0026#34;API_AUDIENCE\u0026#34;) ALGORITHMS = [\u0026#34;RS256\u0026#34;] # Ensure required environment variables are set if not all([AUTH0_DOMAIN, API_AUDIENCE]): raise RuntimeError(\u0026#34;Missing required environment variables\u0026#34;) # Initialize FastAPI app app = FastAPI( title=\u0026#34;Secure API\u0026#34;, description=\u0026#34;API with JWT-based authentication and authorization\u0026#34;, version=\u0026#34;1.0.0\u0026#34; ) # Security scheme bearer_scheme = HTTPBearer() # Pydantic models for response standardization class ErrorResponse(BaseModel): error: str detail: str class SuccessResponse(BaseModel): status: str data: Dict[str, Any] message: str # Cache JWKS with LRU cache @lru_cache(maxsize=1) def fetch_jwks(): try: jwks_url = f\u0026#34;https://{AUTH0_DOMAIN}/.well-known/jwks.json\u0026#34; response = requests.get(jwks_url, timeout=5) response.raise_for_status() return response.json() except requests.RequestException as e: logger.error(f\u0026#34;Failed to fetch JWKS: {str(e)}\u0026#34;) raise HTTPException( status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail=\u0026#34;Unable to fetch authentication keys\u0026#34; ) def get_signing_key(token: str) -\u0026gt; Dict[str, Any]: try: unverified_header = jwt.get_unverified_header(token) kid = unverified_header.get(\u0026#34;kid\u0026#34;) jwks = fetch_jwks() key = next((k for k in jwks[\u0026#34;keys\u0026#34;] if k[\u0026#34;kid\u0026#34;] == kid), None) if key is None: raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\u0026#34;Invalid signing key\u0026#34; ) return key except JWTError as e: logger.error(f\u0026#34;Error processing token header: {str(e)}\u0026#34;) raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=\u0026#34;Invalid token header\u0026#34; ) async def verify_token( credentials: HTTPAuthorizationCredentials = Depends(bearer_scheme) ) -\u0026gt; Dict[str, Any]: token = credentials.credentials try: rsa_key = get_signing_key(token) payload = jwt.decode( token, rsa_key, algorithms=ALGORITHMS, audience=API_AUDIENCE, issuer=f\u0026#34;https://{AUTH0_DOMAIN}/\u0026#34; ) logger.info(f\u0026#34;Token verified for user: {payload.get(\u0026#39;sub\u0026#39;)}\u0026#34;) return payload except ExpiredSignatureError: logger.warning(\u0026#34;Token expired\u0026#34;) raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=ErrorResponse( error=\u0026#34;token_expired\u0026#34;, detail=\u0026#34;The provided token has expired\u0026#34; ).model_dump() ) except JWTError as e: logger.warning(f\u0026#34;Token validation failed: {str(e)}\u0026#34;) raise HTTPException( status_code=status.HTTP_401_UNAUTHORIZED, detail=ErrorResponse( error=\u0026#34;invalid_token\u0026#34;, detail=f\u0026#34;Token validation failed: {str(e)}\u0026#34; ).model_dump() ) async def verify_token_with_scopes( security_scopes: SecurityScopes, payload: Dict[str, Any] = Depends(verify_token) ) -\u0026gt; Dict[str, Any]: token_scopes = payload.get(\u0026#34;scope\u0026#34;, \u0026#34;\u0026#34;).split() missing_scopes = [scope for scope in security_scopes.scopes if scope not in token_scopes] if missing_scopes: logger.warning(f\u0026#34;{datetime.now(timezone.utc).isoformat()}: Missing required scopes: {missing_scopes}\u0026#34;) raise HTTPException( status_code=status.HTTP_403_FORBIDDEN, detail=ErrorResponse( error=\u0026#34;insufficient_scopes\u0026#34;, detail=f\u0026#34;Missing required scopes: {\u0026#39;, \u0026#39;.join(missing_scopes)}\u0026#34; ).model_dump() ) return payload @app.exception_handler(HTTPException) async def http_exception_handler(request, exc): # Handle both dictionary and string detail formats if isinstance(exc.detail, dict): error = exc.detail.get(\u0026#34;error\u0026#34;, \u0026#34;unknown_error\u0026#34;) detail = exc.detail.get(\u0026#34;detail\u0026#34;, str(exc.detail)) else: error = \u0026#34;unknown_error\u0026#34; detail = str(exc.detail) return JSONResponse( status_code=exc.status_code, content={ \u0026#34;error\u0026#34;: error, \u0026#34;detail\u0026#34;: detail } ) @app.get( \u0026#34;/public\u0026#34;, response_model=SuccessResponse, summary=\u0026#34;Public endpoint\u0026#34;, description=\u0026#34;Accessible without authentication\u0026#34; ) async def public_endpoint(): return SuccessResponse( status=\u0026#34;success\u0026#34;, data={}, message=\u0026#34;Successfully accessed public endpoint\u0026#34; ) @app.get( \u0026#34;/private\u0026#34;, response_model=SuccessResponse, summary=\u0026#34;Private endpoint\u0026#34;, description=\u0026#34;Requires valid JWT authentication\u0026#34; ) async def private_endpoint(payload: Dict[str, Any] = Depends(verify_token)): return SuccessResponse( status=\u0026#34;success\u0026#34;, data={\u0026#34;user\u0026#34;: payload}, message=\u0026#34;Successfully accessed private endpoint\u0026#34; ) @app.get( \u0026#34;/private/scoped\u0026#34;, response_model=SuccessResponse, summary=\u0026#34;Scoped private endpoint\u0026#34;, description=\u0026#34;Requires valid JWT with \u0026#39;read:messages\u0026#39; scope\u0026#34; ) async def private_scoped_endpoint( payload: Dict[str, Any] = Security(verify_token_with_scopes, scopes=[\u0026#34;read:messages\u0026#34;]) ): return SuccessResponse( status=\u0026#34;success\u0026#34;, data={\u0026#34;user\u0026#34;: payload}, message=\u0026#34;Successfully accessed scoped private endpoint\u0026#34; ) Start the server $ uvicorn server:app --reload --port 8000 INFO: Will watch for changes in these directories: [\u0026#39;/tmp/auth0-fastapi-api-protection\u0026#39;] INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) INFO: Started reloader process [46327] using WatchFiles INFO: Started server process [46329] INFO: Waiting for application startup. INFO: Application startup complete. Use the access token received to verify if we can access each of the above endpoints as intended $ curl -s http://localhost:8000/public | jq { \u0026#34;status\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: {}, \u0026#34;message\u0026#34;: \u0026#34;Successfully accessed public endpoint\u0026#34; } $ curl -i http://localhost:8000/private \u0026amp;\u0026amp; echo HTTP/1.1 403 Forbidden date: Fri, 18 Apr 2025 19:38:48 GMT server: uvicorn content-length: 54 content-type: application/json {\u0026#34;error\u0026#34;:\u0026#34;unknown_error\u0026#34;,\u0026#34;detail\u0026#34;:\u0026#34;Not authenticated\u0026#34;} $ curl -s http://localhost:8000/private -H \u0026#34;Authorization: Bearer $ACCESS_TOKEN\u0026#34; | jq { \u0026#34;status\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;user\u0026#34;: { \u0026#34;iss\u0026#34;: \u0026#34;https://dev-s6oegu3u80a0upg4.us.auth0.com/\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;XStySocTNNAJkwa7kTNNGqrwYpHmueq7@clients\u0026#34;, \u0026#34;aud\u0026#34;: \u0026#34;https://api.example.com\u0026#34;, \u0026#34;iat\u0026#34;: 1744937316, \u0026#34;exp\u0026#34;: 1745023716, \u0026#34;gty\u0026#34;: \u0026#34;client-credentials\u0026#34;, \u0026#34;azp\u0026#34;: \u0026#34;XStySocTNNAJkwa7kTNNGqrwYpHmueq7\u0026#34;, \u0026#34;permissions\u0026#34;: [] } }, \u0026#34;message\u0026#34;: \u0026#34;Successfully accessed private endpoint\u0026#34; } $ curl -i http://localhost:8000/private/scoped \u0026amp;\u0026amp; echo HTTP/1.1 403 Forbidden date: Fri, 18 Apr 2025 19:39:56 GMT server: uvicorn content-length: 54 content-type: application/json {\u0026#34;error\u0026#34;:\u0026#34;unknown_error\u0026#34;,\u0026#34;detail\u0026#34;:\u0026#34;Not authenticated\u0026#34;} $ curl -s http://localhost:8000/private/scoped -H \u0026#34;Authorization: Bearer $ACCESS_TOKEN\u0026#34; | jq { \u0026#34;status\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;user\u0026#34;: { \u0026#34;iss\u0026#34;: \u0026#34;https://dev-s6oegu3u80a0upg4.us.auth0.com/\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;XStySocTNNAJkwa7kTNNGqrwYpHmueq7@clients\u0026#34;, \u0026#34;aud\u0026#34;: \u0026#34;https://api.example.com\u0026#34;, \u0026#34;iat\u0026#34;: 1745005284, \u0026#34;exp\u0026#34;: 1745091684, \u0026#34;scope\u0026#34;: \u0026#34;read:messages\u0026#34;, \u0026#34;gty\u0026#34;: \u0026#34;client-credentials\u0026#34;, \u0026#34;azp\u0026#34;: \u0026#34;XStySocTNNAJkwa7kTNNGqrwYpHmueq7\u0026#34;, \u0026#34;permissions\u0026#34;: [ \u0026#34;read:messages\u0026#34; ] } }, \u0026#34;message\u0026#34;: \u0026#34;Successfully accessed scoped private endpoint\u0026#34; } Navigate to \u0026ldquo;Applications -\u0026gt; Application -\u0026gt; Default App -\u0026gt; API -\u0026gt; sample-api \u0026quot; drop down and uncheck \u0026ldquo;read:messages\u0026rdquo; permission Generate a new access token without required scopes using the Default App client credentials curl --request POST \\ --url \u0026#34;https://$DOMAIN/oauth/token\u0026#34; \\ --header \u0026#39;content-type: application/json\u0026#39; \\ --data @- \u0026lt;\u0026lt; EOF | jq \u0026#39;.access_token\u0026#39; { \u0026#34;client_id\u0026#34;:\u0026#34;$CLIENT_ID\u0026#34;, \u0026#34;client_secret\u0026#34;:\u0026#34;$CLIENT_SECRET\u0026#34;, \u0026#34;audience\u0026#34;:\u0026#34;https://api.example.com\u0026#34;, \u0026#34;grant_type\u0026#34;:\u0026#34;client_credentials\u0026#34; } EOF Export the token to an environment variable export ACCESS_TOKEN=eyJhbGciOiJSUzI1NiIsI... Attempt all the endpoints again to see the response $ curl -i http://localhost:8000/public \u0026amp;\u0026amp; echo HTTP/1.1 200 OK date: Fri, 18 Apr 2025 00:50:22 GMT server: uvicorn content-length: 60 content-type: application/json {\u0026#34;status\u0026#34;:\u0026#34;success\u0026#34;,\u0026#34;data\u0026#34;:{},\u0026#34;message\u0026#34;:\u0026#34;Successfully accessed public endpoint\u0026#34;} $ curl -i http://localhost:8000/private -H \u0026#34;Authorization: Bearer $ACCESS_TOKEN\u0026#34; \u0026amp;\u0026amp; echo HTTP/1.1 200 OK date: Fri, 18 Apr 2025 00:50:42 GMT server: uvicorn content-length: 394 content-type: application/json {\u0026#34;status\u0026#34;:\u0026#34;success\u0026#34;,\u0026#34;data\u0026#34;:{\u0026#34;user\u0026#34;:{\u0026#34;iss\u0026#34;:\u0026#34;https://dev-s6oegu3u80i0upf0.us.auth0.com/\u0026#34;,\u0026#34;sub\u0026#34;:\u0026#34;XStySocTNNAJkwa7kTNNGqrwYpHmueq7@clients\u0026#34;,\u0026#34;aud\u0026#34;:\u0026#34;https://api.example.com\u0026#34;,\u0026#34;iat\u0026#34;:1745005284,\u0026#34;exp\u0026#34;:1745091684,\u0026#34;scope\u0026#34;:\u0026#34;read:messages\u0026#34;,\u0026#34;gty\u0026#34;:\u0026#34;client-credentials\u0026#34;,\u0026#34;azp\u0026#34;:\u0026#34;XStySocTNNAJkwa7kTNNGqrwYpHmueq7\u0026#34;,\u0026#34;permissions\u0026#34;:[\u0026#34;read:messages\u0026#34;]}},\u0026#34;message\u0026#34;:\u0026#34;Successfully accessed private endpoint\u0026#34;} # Token fails to validate due to missing scope $ curl -i http://localhost:8000/private/scoped -H \u0026#34;Authorization: Bearer $ACCESS_TOKEN\u0026#34; \u0026amp;\u0026amp; echo HTTP/1.1 403 Forbidden date: Fri, 18 Apr 2025 19:45:40 GMT server: uvicorn content-length: 81 content-type: application/json {\u0026#34;error\u0026#34;:\u0026#34;insufficient_scopes\u0026#34;,\u0026#34;detail\u0026#34;:\u0026#34;Missing required scopes: read:messages\u0026#34;} References class fastapi.security.HTTPBearer SecurityScopes fastAPI.Security FasptAPI dependency injection Add Authorization to Your Flask API Application Auth0 API protection service settings ","permalink":"https://partbypart.github.io/posts/deep-dive-setup-auth0-authentication-authorization/","summary":"Learn how to protect your FastAPI API endpoints using Auth0","title":"Protect FastAPI API endpoints with Auth0"},{"content":"Have you come across any such consent/sign-in forms while using any app?\nIf \u0026ldquo;yes\u0026rdquo;, that\u0026rsquo;s an OAuth flow!\nWhat is OAuth? OAuth (\u0026ldquo;Open Authorization\u0026rdquo;) is a standard authorization protocol designed to allow a website or application to access resources hosted by other web apps on behalf of a user. It allows consented access and restricts actions of what a client app can perform on user resources on behalf of the user, without ever sharing the user\u0026rsquo;s credentials.\n\u0026#x26a0;\u0026#xfe0f; Did you notice it\u0026rsquo;s an authorization protocol and not an authentication protocol?\nAuthentication verifies who a user is, confirming their identity. It answers, \u0026ldquo;Are you who you claim to be?\u0026rdquo;. Authorization determines what a verified user or system can do, defining their permissions or access rights (e.g., read, write, admin). It answers, \u0026ldquo;What are you allowed to do?\u0026rdquo; Authentication is about identity verification; authorization is about access control. Authentication typically happens first, followed by authorization to enforce appropriate privileges.\nWhy OAuth? A picture is worth a thousand \u0026hellip; Oops! the picture has words. Never mind. Here\u0026rsquo;s why\nhttps://commons.wikimedia.org/wiki/File:Without-oauth.png\nExample NOTE: Yelp used to ask for gmail password. It no longer does. Thanks to OAuth! https://blog.codinghorror.com/content/images/2025/04/image-137.png\nAccess tokens OAuth 2.0 uses Access Tokens to authorize a client (third party application) to access a user\u0026rsquo;s resource on their behalf. An Access Token is a piece of data that represents the authorization to access resources on behalf of the end-user. OAuth 2.0 doesn’t define a specific format for Access Tokens. However, JSON Web Token (JWT) format is often used.\nExample access token eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJodHRwczovL2F1dGguZXhhbXBsZS5jb20iLCJzdWIiOiIxMjM0NTY3ODkwIiwiaWF0IjoxNzI4ODA2NDAwLCJleHAiOjE3Mjg4MTAwMDAsInNjb3BlIjoicmVhZDpwcm9maWxlIHdyaXRlOmVtYWlsIn0.XYZ123abc456789signature Access token contents can be verified in jwt.io\nRefresh tokens Issued by the authorization server when issuing an access token. Issued to the client by the authorization server and are used to obtain a new access token when the current access token becomes invalid or expires. Issuing a refresh token is optional at the discretion of the authorization server. Example refresh token export REFRESH_TOKEN=v1.MaOB4pVc1m7nAVKMkWL_dyJrrOKf... # Get a new access token using a valid refresh token curl --request POST \\ --url https://$AUTHORIZATION_SERVER/oauth/token \\ --header \u0026#39;Accept: application/json\u0026#39; \\ --header \u0026#39;Content-Type: application/x-www-form-urlencoded\u0026#39; \\ --data grant_type=refresh_token \\ --data \u0026#34;client_id=$CLIENT_ID\u0026#34; \\ --data \u0026#34;client_secret=$CLIENT_SECRET\u0026#34; \\ --data \u0026#34;refresh_token=$REFRESH_TOKEN\u0026#34; | jq { \u0026#34;access_token\u0026#34;: \u0026#34;eyJhbGciOiJ...Nh_gN4oA\u0026#34;, \u0026#34;refresh_token\u0026#34;: \u0026#34;v1.MvWdb4U...eei8H7_l6o\u0026#34;, \u0026#34;id_token\u0026#34;: \u0026#34;eyJhbGc...A0PsvHGw\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;openid profile email offline_access\u0026#34;, \u0026#34;expires_in\u0026#34;: 86400, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34; } Roles OAuth defines four roles\nResource owner: An entity capable of granting access to a protected resource. When the resource owner is a person, it is referred to as an end-user. Resource owner is the user or system that owns the protected resources and can grant access to them.\nExamples:\nA user with a google account is a resource owner. A user with a github account is a resource owner. A user with a reddit account is a resource owner. Resource server: The server hosting the protected resources, capable of accepting and responding to protected resource requests using access tokens. Example resource servers:\nhttps://www.googleapis.com/calendar/v3 https://gmail.googleapis.com https://photoslibrary.googleapis.com https://generativelanguage.googleapis.com Client: An application making protected resource requests on behalf of the resource owner and with its authorization. To access resources, the Client must hold the appropriate Access Token. Example:\nNotion mail is a client to access gmail. Apple calendar is a client to access calendars from various resource servers of Google, Yahoo etc. Authorization server: The server issuing access tokens to the client after successfully authenticating the resource owner and obtaining authorization. Example:\nhttps://oauth2.googleapis.com/token is an authorization server that can issue tokens to access to various services Google access tokens https://github.com/login/oauth/access_token is an authorization server that can issue tokens to access Github NOTE: The authorization server may be the same server as the resource server or a separate entity\nPrerequisites for OAuth Before a client offers any oauth workflow to a user, the third party client has to register itself as a client on Authorization server\u0026rsquo;s website to get a client_id, client_secret and register a valid redirect URL for callback Examples: Create a Reddit app Create a spotify app Client types Confidential: Clients capable of maintaining the confidentiality of their credentials (e.g., client implemented on a secure server with restricted access to the client credentials), or capable of secure client authentication using other means.\nExamples https://photon-reddit.com/ https://www.notion.com/product/mail https://www.notion.com/product/calendar Public: Clients incapable of maintaining the confidentiality of their credentials (e.g., clients executing on the device used by the resource owner, such as an installed native application or a web browser-based application), and incapable of secure client authentication via any other means\nExamples Any single page application with no backend Smart TV Clients will choose an authorization grant type based on whether they\u0026rsquo;re confidential or public.\nReferences The OAuth 2.0 Authorization Framework - Roles What is OAuth 2 - Auth0 ","permalink":"https://partbypart.github.io/posts/quick-bytes-oauth-2.0/","summary":"Learn key concepts of OAuth 2.0","title":"Quick bytes - Introduction to OAuth 2.0"},{"content":"Introduction Ctags generates an index (or tag) file of language objects found in source files that allows these items to be quickly and easily located by a text editor or other utility. A tag signifies a language object for which an index entry is available. Vim is the official editor of ctags (No vim plugin required). Plain and simple: ctags lets us jump around our source code using tags and a stack. Ctags (specifically Exuberant Ctags, not the BSD version shipped with OS X) indexes source code to make it easy to jump to functions, variables, classes, and other identifiers in (among other editors) Vim (see :help tags in vim normal mode). Prerequisites Any Linux based OS with vim Source code in any of the ctags supported programming languages Installation Ubuntu $ sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install -y exuberant-ctags CentOS $ sudo yum update \u0026amp;\u0026amp; sudo yum install -y ctags MacOS # Some MacOS comes with ctags $ /usr/bin/ctags usage: ctags [-BFadtuwvx] [-f tagsfile] file ... # Don\u0026#39;t use that default ctags. Install Exuberant Ctags from homebrew $ brew install ctags $ alias ctags=\u0026#34;`brew --prefix`/bin/ctags\u0026#34; $ alias ctags \u0026gt;\u0026gt; ~/.bash_profile $ which ctags /usr/local/bin/ctags Windows (Use the following OS instead) Download CentOS Download Ubuntu Download Manjaro Download Fedora How to generate tags file? cd to the root directory of your source code Run Ctags recursively over the entire source code to generate the tags file Command to generate tags: # Example: Source code is in \u0026#39;openssl\u0026#39; directory $ cd openssl $ ctags --recurse=yes --exclude=.git --exclude=BUILD --exclude=.svn \\ --exclude=vendor/* --exclude=node_modules/* --exclude=db/* \\ --exclude=log/* $ ls -la tags -rw-r--r-- 1 alice dev 3640065 Jan 24 23:11 tags It would be silly to specify the long command in every source code directory. ~/.ctags file to our rescue! Just list all the commonly used arguments of ctags and place it in your home directory and call it .ctags $ cat ~/.ctags --recurse=yes --exclude=.git --exclude=BUILD --exclude=.svn --exclude=*.js --exclude=vendor/* --exclude=node_modules/* --exclude=db/* --exclude=log/* --exclude=\\*.min.\\* --exclude=\\*.swp --exclude=\\*.bak --exclude=\\*.pyc --exclude=\\*.class --exclude=\\*.sln --exclude=\\*.csproj --exclude=\\*.csproj.user --exclude=\\*.cache --exclude=\\*.dll --exclude=\\*.pdb If we have a ~/.ctags file, we can just enter our source code directory and generate a tags file using: $ pwd /home/alice/openssl $ ctags $ ls tags tags NOTE:\nFeel free to exclude any other directories you don\u0026rsquo;t wish to search. Feel free to explore and use the wealth of ctags command options How to use tags? To search for a specific tag and open Vim with its definition, run the following command in your shell: $ vim -t \u0026lt;tag\u0026gt; Demo: Open any source file in Vim and use the following basic commands: Keyboard command Action Ctrl + ] OR g] OR :ta[g] Ctrl+rw Jump to the tag underneath the cursor using the information in the tags file(s) :ts[elect] \u0026lt;tag_name\u0026gt; List the tags that match \u0026lt;tag_name\u0026gt;, using the information in the tags file(s). When \u0026lt;tag_name\u0026gt; is not given, the last tag name from the tag stack is used :pts[elect] \u0026lt;tag_name\u0026gt; Does :tselect and shows the new tag in a \u0026ldquo;Preview\u0026rdquo; window (horizontal split) without moving the cursor Ctrl + w }OR :ptag Ctrl+rw Opens a preview window with the location of the tag definition. The cursor does not change its position, so tag stack is not updated Ctrl + wz OR :pc Close preview window created by the command Ctrl+w } Ctrl + w Ctrl + ] Open the definition in a horizontal split :tn Jump to next matching tag (If there are multiple matches) :tp Jump to previous matching tag (If there are multiple matches) Ctrl-t Jump back up in the tag stack :tags Show the contents of the tag stack. The active entry is marked with a \u0026gt; Ctrl+rw pastes the word under cursor in command mode. It\u0026rsquo;s just a quick copy paste command in vim\nDemo NOTE: vim commands will appear in the bottom left of the screen. Watching the demo in full screen is recommended for laptops.\nNOTE:\nI\u0026rsquo;ve just listed the basic shortcuts and commands that make sense to me and fit my typing speed. There are tons of other shortcuts and similar looking commands in :help tag . Feel free to use anything that suits your speed/workflow Of course there are plenty of plugins out there with bells and whistles. I just don\u0026rsquo;t like plugins. tag-regexp The tag commands also accept a regular expression argument. When using a pattern, case is ignored. If you want to match case, use \\C in the pattern. When the argument starts with /, it is used as a regex pattern. If the argument does not start with /, it is taken literally, as a full tag name. Examples:\n:tag main jumps directly to the tag \u0026ldquo;main\u0026rdquo; :tag /^get jumps to the tag that starts with \u0026ldquo;get\u0026rdquo; :tag /Final$ jumps to the tag that ends with \u0026ldquo;Final\u0026rdquo; :tag /norm lists all the tags that contain \u0026ldquo;norm\u0026rdquo;, including \u0026ldquo;id_norm\u0026rdquo; :tag /Final$\\C lists all the tags that end with \u0026ldquo;Final\u0026rdquo; (Doesn\u0026rsquo;t match \u0026ldquo;Cipher_final\u0026rdquo; or \u0026ldquo;SHA_FINAL\u0026rdquo;) When the argument both exists literally, and match when used as a regexp, a literal match has a higher priority. For example, :tag /open matches \u0026ldquo;open\u0026rdquo; before \u0026ldquo;open_file\u0026rdquo; and \u0026ldquo;file_open\u0026rdquo;.\nDemo: Notes:\nPeople have written whole books just for regex. This demo doesn\u0026rsquo;t cover the complex patterns This demo covers the regular expressions that I use frequently and are simple to remember Feel free to try out your complex regex (regex101) Sample regex searches with vim Requirement Command Search tags containing \u0026lsquo;aes\u0026rsquo; vim -t '/aes' Search tags ending with \u0026lsquo;sha1\u0026rsquo; vim -t '/sha1$' Search tags beginning with \u0026rsquo;evp\u0026rsquo; and ending with \u0026lsquo;sha1\u0026rsquo; vim -t '/^evp\\w\\+sha1$' Search tags beginning with \u0026lsquo;EVP\u0026rsquo; and ending with \u0026lsquo;sha1\u0026rsquo;(case sensitive) vim -t '/^EVP\\w\\+sha1$\\C' Search tags beginning with \u0026rsquo;evp\u0026rsquo;, ending with \u0026lsquo;sha1\u0026rsquo; and containing \u0026lsquo;aes_xxx\u0026rsquo; in between vim -t '/^evp\\w\\+aes_\\d\\d\\d\\w\\+sha1$' Search tags beginning with alphabets (no numbers) and ending with \u0026lsquo;sha1\u0026rsquo; vim -t '/^[a-zA-Z]\\w\\+sha1$' Keeping the index file up-to-date The major downside to Ctags is having to manually rebuild that index all the time. There are multiple ways of automating this stuff:\nAutocmd to update ctags file Effortless Ctags with Git AutoTag:Updates entries in a tags file automatically when saving However, here\u0026rsquo;s an easy one using vim autocommands: Add the following lines to your ~/.vimrc file.\nCreate a ~/.vimrc if it doesn\u0026rsquo;t exist\n\u0026#34; Auto generate tags file on file write of *.c and *.h files autocmd BufWritePost *.c,*.h silent! !ctags . \u0026amp; Where,\n:au[tocmd] [group] {event} {pat} [nested] {cmd} Add {cmd} to the list of commands that Vim will execute automatically on {event} for a file matching {pat} |autocmd-patterns|. BufWritePost After writing the whole buffer to a file \u0026amp; Run the command in background silent! Execute {cmd} silently. Skip error messages too(!) *.c,*.h Files with extension .c and .h Example If you\u0026rsquo;re in openssl source code directory, add the following lines to crypto/aes/aes_cbc.c and exit the file using vim command :wq!\nvoid foo_function_to_execute_bar(){ printf(\u0026#34;Useless function\u0026#34;); } Verify tags file:\n$ grep \u0026#34;foo_function_to_execute_bar\u0026#34; tags foo_function_to_execute_bar\tcrypto/aes/aes_cbc.c\t/^void foo_function_to_execute_bar(){$/;\u0026#34;\tf Of course it\u0026rsquo;s going to rebuild the entire index and take a lot of time for large projects. Remember, I said it\u0026rsquo;s easy (not quick)\nReferences: Languages supported Supported Editors ctags website ctags(1) - Linux man page What is ctags? How to use ctags with vi Negative Lookbehind in vim Negative lookahead Negative lookbehind Credits Darren Brent Hiebert (Creator of Exuberant Ctags) ","permalink":"https://partbypart.github.io/posts/getting-started-vim-with-ctags/","summary":"Introduction Ctags generates an index (or tag) file of language objects found in source files that allows these items to be quickly and easily located by a text editor or other utility. A tag signifies a language object for which an index entry is available. Vim is the official editor of ctags (No vim plugin required). Plain and simple: ctags lets us jump around our source code using tags and a stack.","title":"Getting started - Vim with ctags"},{"content":"Prerequisites Linux/MacOS openssl command line tool (version 3.x.x) Sign a file using openssl pkeyutl openssl pkeyutl does not calculate the digest of given file by default to create a signature. So, there are two ways to calculate the signature of a given file. Multi-step process: Calculate the digest of the file and sign the digest directly. By default, openssl pkeyutl uses EVP_PKEY_sign() to sign data. EVP_PKEY_sign() does not hash the data to be signed, and therefore is normally used to sign digests. Single-step process: Use -rawin parameter (OpenSSL 3.x +) to let the pkeyutl command calculate the digest and sign the digest. NOTE: OpenSSL 1.x.x does not support -rawin parameter Multi-step process Calculate digest of file in binary $ ~/bin/openssl@3.0.8 dgst -sha256 -binary \\ -out 1GB-file.sha256.checksum \\ ~/data/1GB-file Where, dgst: Command to create a digest. -\u0026lt;digest\u0026gt;: name of a supported digest. -binary: Output the digest or signature in binary form. -out \u0026lt;file_name\u0026gt;: File name to store checksum in binary \u0026lt;file_name\u0026gt;: Input file for digest creation. Sign the digest using private key $ ~/bin/openssl@3.0.8 pkeyutl -sign \\ -pkeyopt digest:sha256 \\ -inkey id_rsa.pem \\ -in 1GB-file.sha256.checksum \\ -out 1GB-file.sig.pkeyutl $ du -b 1GB-file.sig.pkeyutl 256\t1GB-file.sig.pkeyutl Where, pkeyutl: command used to perform public key operations. -sign: sign the input data and output the signed result. This requires a private key. -pkeyopt opt:value: Extra option to specify for signing. Signature generated without this option cannot be verified using openssl dgst when RSA is used (Reference). -inkey \u0026lt;private_key\u0026gt;: the input key file. (private key to sign) -in \u0026lt;filename\u0026gt;: input filename to read data from. (Digest to sign) -out \u0026lt;filename\u0026gt;: output filename to write to. (File to store signature) Single-step process Calculate the digest and sign the digest with a single command $ ~/bin/openssl@3.0.8 pkeyutl -digest sha256 \\ -inkey id_rsa.pem \\ -sign -rawin \\ -out 1GB-file.sig.pkeyutl \\ -in ~/data/1GB-file $ du -b 1GB-file.sig.pkeyutl 256\t1GB-file.sig.pkeyutl Where, -rawin: This indicates that the input data is raw data, which is not hashed by any message digest algorithm. Verify the signature of a file using openssl pkeyutl openssl pkeyutl can be used to verify digital signatures generated by openssl dgst or openssl pkeyutl. openssl pkeyutl does not calculate the digest of given input file by default for verifying the signature. So, there are two ways to verify the signature of a given file. Multi-step process: Calculate the digest of the file and verify the digest directly. By default, openssl pkeyutl uses EVP_PKEY_verify() to verify signature. EVP_PKEY_verify() does not hash the data to be verified. Single-step process: Use -rawin parameter (OpenSSL 3.x +) to let the pkeyutl command calculate the digest and sign the digest. This option uses EVP_DigestVerify() that hashes data before verifying the signature.NOTE: OpenSSL 1.x.x does not support -rawin parameter Multi-step process Calculate digest of file in binary $ ~/bin/openssl@3.0.8 dgst -sha256 -binary \\ -out 1GB-file.sha256.checksum \\ ~/data/1GB-file Where, dgst: Command to create a digest. -\u0026lt;digest\u0026gt;: name of a supported digest. -binary: Output the digest or signature in binary form. -out \u0026lt;file_name\u0026gt;: File name to store checksum in binary \u0026lt;file_name\u0026gt;: Input file for digest creation. Verify the digest using public key # Verify the signature by providing the digest $ ~/bin/openssl@3.0.8 pkeyutl -in 1GB-file.sha256.checksum \\ -pkeyopt digest:sha256 \\ -sigfile 1GB-file.sig \\ -verify -pubin \\ -inkey id_rsa.pub.pem Signature Verified Successfully Where, pkeyutl: command used to perform public key operations. -in \u0026lt;filename\u0026gt;: input filename to read data from. (Digest of file if -rawin is not used) -pkeyopt opt:value: Extra option to specify for signing/verifying. Verification with an RSA key cannot be done if this option is not specified (Reference). -sigfile \u0026lt;file_name\u0026gt;: Signature file, required for -verify operations only. -verify: Verify the input data (which must be a hash unless -rawin is specified) against the signature file and indicate if the verification succeeded or failed. -pubin: The input file is a public key. -inkey \u0026lt;public_key\u0026gt;: the input key file. (public key to verify) Single-step process Calculate the digest and verify the signature with a single command $ ~/bin/openssl@3.0.8 pkeyutl -digest sha256 \\ -rawin -in ~/data/1GB-file \\ -sigfile 1GB-file.sig.pkeyutl \\ -verify -pubin \\ -inkey id_rsa.pub.pem Signature Verified Successfully Where, -rawin: This indicates that the input data is raw data, which is not hashed by any message digest algorithm. References Difference between openssl-dgst and openssl-pkeyutl OpenSSL 3 - openssl-pkeyutl OpenSSL 3 - EVP_DigestVerify() ","permalink":"https://partbypart.github.io/posts/quick-bytes-sign-verify-with-openssl-pkeyutl/","summary":"Learn to sign and verify a file using openssl pkeyutl command","title":"Quick bytes - Sign and verify a file using openssl-pkeyutl"},{"content":"Steps Install required build tools and prerequisites Rocky Linux $ sudo groupinfo \u0026#34;Development tools\u0026#34; |less $ sudo yum update -y \u0026amp;\u0026amp; sudo yum groupinstall -y \u0026#34;Development tools\u0026#34; ... $ sudo yum install -y perl ... # Install curl if not installed already $ curl --version \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 || \\ { echo \u0026#34;Curl not found. Installing Curl...\u0026#34;; sudo yum install -y curl; } $ mkdir -p ~/downloads ~/installed Ubuntu $ sudo apt update \u0026amp;\u0026amp; sudo apt install build-essential curl perl $ mkdir -p ~/downloads ~/installed ... Download and untar required openssl version source $ curl -L https://www.openssl.org/source/openssl-3.0.8.tar.gz | \\ tar xvz -C ~/downloads/ OpenSSL 3.0.8 is the FIPS validated version (Certificate)(Valid until: 9/21/2026) Create a build directory and check platform support $ cd ~/downloads/openssl-3.0.8 $ mkdir BUILD \u0026amp;\u0026amp; cd BUILD $ uname -sm Linux aarch64 $ ../Configure LIST | grep linux-aarch linux-aarch64 Configure Makefile for build In previous versions of OpenSSL, the config script determined the platform type and compiler and then called Configure. Starting with OpenSSL 3, they are the same. Configure the Makefile $ pwd /home/alice/downloads/openssl-3.0.8/BUILD $ export PREFIXDIR=$HOME/installed/openssl-3.0.8 $ CFLAGS=\u0026#34;-ggdb3 -O0\u0026#34; ../Configure --api=1.1.0 no-deprecated --debug \\ --openssldir=$PREFIXDIR/ssl --prefix=$PREFIXDIR --strict-warnings \\ no-asm no-shared enable-fips enable-trace threads Configuring OpenSSL version 3.0.8 for target linux-aarch64 Using os-specific seed configuration Created configdata.pm Running configdata.pm Created Makefile.in Created Makefile Created include/openssl/configuration.h ********************************************************************** *** *** *** OpenSSL has been successfully configured *** *** *** *** If you encounter a problem while building, please open an *** *** issue on GitHub \u0026lt;https://github.com/openssl/openssl/issues\u0026gt; *** *** and include the output from the following command: *** *** *** *** perl configdata.pm --dump *** *** *** *** (If you are new to OpenSSL, you might want to consult the *** *** \u0026#39;Troubleshooting\u0026#39; section in the INSTALL.md file first) *** *** *** ********************************************************************** # Verify if our config options are in use $ perl configdata.pm --dump | grep \u0026#34;\\\u0026lt;CFLAGS\\\u0026gt; \\|asm_arch\u0026#34; CFLAGS =\u0026gt; \u0026#34;-Wall -O0 -g\u0026#34;, asm_arch =\u0026gt; \u0026#34;aarch64\u0026#34;, CFLAGS = -ggdb3 -O0 CFLAGS = -ggdb3 -O0 -DPEDANTIC -pedantic -Wno-long-long \\ -DUNUSEDRESULT_DEBUG -Wall -Wmissing-declarations -Wextra \\ -Wno-unused-parameter -Wno-missing-field-initializers -Wswitch \\ -Wsign-compare -Wshadow -Wformat \\ -Wtype-limits -Wundef -Werror -Wmissing-prototypes -Wstrict-prototypes Where, CFLAGS: Environment variable that can be set to specify additional switches to be passed to a compiler -ggdb3: Produce debugging information for use by GDB. Level 3 includes extra information, such as all the macro definitions present in the program -O0: Most optimizations are completely disabled --api=1.1.0 no-deprecated: Remove support for all APIs that were deprecated in OpenSSL version 1.1.0 or below. --debug: Build OpenSSL with debugging symbols and zero optimization level. --openssldir: Directory for OpenSSL configuration files, and also the default certificate and key store. OpenSSL binary and applications linked with OpenSSL libraries will look for openssl.cnf by default in the directory specified with --openssldir The directory should be chosen carefully to reflect the openssl.cnf path on machines where OpenSSL or applications linked with OpenSSL are installed (not where they\u0026rsquo;re built) --prefix: The top of the installation directory tree OpenSSL binary and applications linked with OpenSSL libraries will look for OpenSSL modules by default in the following directory structure: \u0026lt;prefix_directory\u0026gt;/lib/ossl-modules The directory should be chosen carefully to reflect the paths on machines where OpenSSL or applications linked with OpenSSL are installed (not where they\u0026rsquo;re built) Do not worry about having the same path prefix (as installed machine) on the build machine. Artifacts on build machine can be installed at any arbitrary path of your choice using DESTDIR option of make --strict-warnings: A developer flag that switches on various compiler options recommended for OpenSSL development. It only works when using gcc or clang as the compiler. no-asm: Do not use assembler code. Ideal for debugging/troubleshooting option and not for production use no-shared: Do not create shared libraries, only static ones. enable-fips: Build (and install) the FIPS provider enable-trace: Build with support for the integrated tracing api. threads: Build with support for multi-threaded applications Build the artifacts $ pwd /home/alice/downloads/openssl-3.0.8/BUILD $ make -j$(nproc) 2\u0026gt;\u0026amp;1 | tee /tmp/ossl3-make-output-$(date +\u0026#34;%b-%d-%Y\u0026#34;).log.0 ... /usr/bin/perl \u0026#34;-I.\u0026#34; -Mconfigdata \u0026#34;../util/dofile.pl\u0026#34; \\ \u0026#34;-oMakefile\u0026#34; ../util/wrap.pl.in \u0026gt; \u0026#34;util/wrap.pl\u0026#34; chmod a+x util/wrap.pl make[1]: Leaving directory \u0026#39;/home/alice/downloads/openssl-3.0.8/BUILD\u0026#39; Where, $(nproc): The number of CPU cores/threads available 2\u0026gt;\u0026amp;1: File descriptor 1 is the standard output (stdout). File descriptor 2 is the standard error (stderr). Redirect stderr to a file named stdout \u0026amp; indicates that what follows and precedes is a file descriptor, and not a filename tee: Using tee, you redirect stdin both to stdout and to the file specified as argument to tee Verify if the installer will be installing the artifacts in required build machine path. Note that this verification does not install the artifacts. It\u0026rsquo;s a dry-run. $ make DESTDIR=/tmp -n install_fips | grep -m1 \u0026#34;fips.so\u0026#34; echo \u0026#34;install providers/fips.so -\u0026gt; \\ /tmp/home/alice/installed/openssl-3.0.8/lib/ossl-modules/fips.so\u0026#34; As you can see, DESTDIR is the prefix for --prefix option given during configuration. The applications and libraries however are built with their MODULESDIR configured as /home/alice/installed/openssl-3.0.8. DESTDIR does not affect any existing artifact configurations. It is purely used for installing the artifacts on build machine. $ pwd /home/alice/downloads/openssl-3.0.8/BUILD $ ./apps/openssl version -m MODULESDIR: \u0026#34;/home/alice/installed/openssl-3.0.8/lib/ossl-modules\u0026#34; NOTE: It\u0026rsquo;s not mandatory to use DESTDIR if your build machine and installer machine are the same Run self tests (optional) $ pwd /home/alice/downloads/openssl-3.0.8/BUILD $ make test ... Install artifacts on a given path $ make install_sw install_fips install_ssldirs ... DESTDIR is not required if build machine and installed machine are same (Meaning: OpenSSL binary and libraries will be used on the same machine where it\u0026rsquo;s built) Check artifacts $ find $PREFIXDIR -type f \\ \\( -name fipsmodule.cnf -o -name fips.so -o -name legacy.so \\ -o -name openssl -o -name libcrypto.a -o -name libssl.a \\ -o -name openssl.cnf \\) /home/alice/installed/openssl-3.0.8/bin/openssl /home/alice/installed/openssl-3.0.8/ssl/openssl.cnf /home/alice/installed/openssl-3.0.8/ssl/fipsmodule.cnf /home/alice/installed/openssl-3.0.8/lib/libssl.a /home/alice/installed/openssl-3.0.8/lib/libcrypto.a /home/alice/installed/openssl-3.0.8/lib/ossl-modules/fips.so /home/alice/installed/openssl-3.0.8/lib/ossl-modules/legacy.so Install FIPS provider The Installation of the FIPS provider consists of two steps. In the first step, the shared library of fips (fips.so) is copied to its installed location (The location set in MODULESDIR in step 6) In the second step, the openssl fipsinstall command is executed, which completes the installation by doing the following two things: Runs the FIPS module self tests Generates the so-called FIPS module configuration file containing information about the module such as the module checksum (and for OpenSSL 3.0 the self test status). The FIPS module must have the self tests run, and the FIPS module config file output generated on every machine that it is to be used on. Commands Make sure fips.so is available in MODULESDIR directory $ ls /home/alice/installed/openssl-3.0.8/lib/ossl-modules/fips.so home/alice/installed/openssl-3.0.8/lib/ossl-modules/fips.so Run the openssl fipsinstall command # Contents of fipsmodule.cnf before running the command $ cat $PREFIXDIR/ssl/fipsmodule.cnf [fips_sect] activate = 1 conditional-errors = 1 security-checks = 1 module-mac = CD:74:E1:72:68:F9:3F:E2:CA:71:CE:E4:4E:89:33:81:F8:0D:05:E9:9E:41:D5:40:DA:92:01:B9:4F:A9:69:6B $ $PREFIXDIR/bin/openssl fipsinstall -out $PREFIXDIR/ssl/fipsmodule.cnf \\ -module $PREFIXDIR/lib/ossl-modules/fips.so # Contents of fipsmodule.cnf after running the command $ cat $PREFIXDIR/ssl/fipsmodule.cnf [fips_sect] activate = 1 install-version = 1 conditional-errors = 1 security-checks = 1 module-mac = CD:74:E1:72:68:F9:3F:E2:CA:71:CE:E4:4E:89:33:81:F8:0D:05:E9:9E:41:D5:40:DA:92:01:B9:4F:A9:69:6B install-mac = 41:9C:38:C2:8F:59:09:43:2C:AA:2F:58:36:2D:D9:04:F9:6C:56:8B:09:E0:18:3A:2E:D6:CC:69:05:04:E1:11 install-status = INSTALL_SELF_TEST_KATS_RUN Verify FIPS provider usage # MD5 checksum calculation without fips mode activated $ echo -n \u0026#34;helloworld\u0026#34; | $PREFIXDIR/bin/openssl md5 MD5(stdin)= fc5e038d38a57032085441e7fe7010b0 # Make a temporary copy for testing $ cp $PREFIXDIR/ssl/openssl.cnf /tmp/openssl.cnf # Enable fips section by uncommenting \u0026#34;fips = fips_sect\u0026#34; $ sed -i \u0026#39;s/^# fips =/fips =/\u0026#39; /tmp/openssl.cnf $ grep \u0026#34;fips = \u0026#34; /tmp/openssl.cnf fips = fips_sect # Uncomment and include \u0026#34;fipsmodule.cnf\u0026#34; in openssl.cnf $ sed -i \u0026#39;s/^# .include fipsmodule.cnf/.include fipsmodule.cnf/\u0026#39; /tmp/openssl.cnf # Attempting to run md5 with fips module enabled should throw an error $ echo -n \u0026#34;helloworld\u0026#34; | \\ OPENSSL_CONF_INCLUDE=$PREFIXDIR/ssl/ \\ OPENSSL_CONF=/tmp/openssl.cnf $PREFIXDIR/bin/openssl md5 Error setting digest A03EA49FFFFF0000:error:0308010C:digital envelope routines:inner_evp_generic_fetch:unsupported:../crypto/evp/evp_fetch.c:373:Global default library context, Algorithm (MD5 : 102), Properties () A03EA49FFFFF0000:error:03000086:digital envelope routines:evp_md_init_internal:initialization error:../crypto/evp/digest.c:254: Where, OPENSSL_CONF_INCLUDE: Directory path to be prefixed for .include directives in openssl.cnf OPENSSL_CONF: Custom openssl.cnf to be used for the given command References OpenSSL download source OpenSSL Install options and instructions OpenSSL Build and Install documentation OpenSSL 3.0.8 Certificate gcc debugging options OpenSSL Makefile targets OpenSSL configuration options FIPS provider installation OpenSSL environment variables ","permalink":"https://partbypart.github.io/posts/build-and-install-openssl3-with-fips/","summary":"Learn how to build and install OpenSSL 3 (with fips module) on Linux","title":"Build and Install OpenSSL 3 with FIPS module"},{"content":"Prerequisites Linux/MacOS openssl command line tool (version 1.0.2 or higher) RSA key components 101 - ASN.1, DER, PEM, PKCS#1, PKCS#8 Quick bytes - Basics of Distinguished Encoding Rules Part 1 - ASN.1 syntax to store RSA public key in SubjectPublicKeyInfo format SubjectPublicKeyInfo syntax SubjectPublicKeyInfo ::= SEQUENCE { algorithm AlgorithmIdentifier, subjectPublicKey BIT STRING -- \u0026#34;RSAPublicKey\u0026#34; for an RSA public key } AlgorithmIdentifier ::= SEQUENCE { algorithm OBJECT IDENTIFIER, parameters ANY DEFINED BY algorithm OPTIONAL } RSAPublicKey ::= SEQUENCE { modulus INTEGER, -- n publicExponent INTEGER -- e } The DER encoded RSAPublicKey is the value of the BIT STRING of subjectPublicKey (Reference). With OpenSSL 1.0.2 or higher, the following command generates an RSA public key in SubjectPublicKeyInfo format by default. openssl rsa -pubout -in \u0026lt;rsa_private_key.pem\u0026gt; -out \u0026lt;rsa_public_key.pem\u0026gt; Verifying SubjectPublicKeyInfo RSA public key syntax using openssl command $ openssl version -v OpenSSL 1.0.2s 28 May 2019 # Create a sample 2048 bit RSA private key $ openssl genrsa -out /tmp/id_rsa_2048_pkcs1.pem 2048 # Create the corresponding RSA public key in PKCS#1 format $ openssl rsa -in /tmp/id_rsa_2048_pkcs1.pem -pubout -out /tmp/id_rsa_2048_spki.pub.pem writing RSA key $ grep \u0026#34;BEGIN\\|END\u0026#34; /tmp/id_rsa_2048_spki.pub.pem -----BEGIN RSA PUBLIC KEY----- -----END RSA PUBLIC KEY----- $ openssl asn1parse -in /tmp/id_rsa_2048_spki.pub.pem -i 0:d=0 hl=4 l= 290 cons: SEQUENCE 4:d=1 hl=2 l= 13 cons: SEQUENCE 6:d=2 hl=2 l= 9 prim: OBJECT :rsaEncryption 17:d=2 hl=2 l= 0 prim: NULL 19:d=1 hl=4 l= 271 prim: BIT STRING # Dig into the BIT STRING TO observe the RSA public key information (Offset is 19 as seen above) $ openssl asn1parse -in /tmp/id_rsa_2048_spki.pub.pem -i -strparse 19 0:d=0 hl=4 l= 266 cons: SEQUENCE 4:d=1 hl=4 l= 257 prim: INTEGER :AEF7...AC15 265:d=1 hl=2 l= 3 prim: INTEGER :010001 Part 2 - Commonly used tag values Tag (hex) Type 0x02 INTEGER 0x03 BIT STRING 0x04 OCTET STRING 0x05 NULL 0x06 OBJECT IDENTIFIER 0x0C UTF8String 0x10 (0x30*) SEQUENCE and SEQUENCE OF 0x11 (0x31*) SET and SET OF * The two tags marked with a * are always encoded as 0x30 or 0x31, because bit 6 is used to indicate whether a field is Constructed vs Primitive. These tags are always Constructed, so their encoding has bit 6 set to 1.\nHere is the complete list of Identifier octets for tags used in DER Part 3 - Steps to dissect a public key generated by openssl Lets use a sample 2048 bit RSA public key in SubjectPublicKeyInfo format as an example.\n$ cat /tmp/id_rsa_2048_spki.pub.pem -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArvcdS5hY0rxJnhGOsmRv lUBP3WFGcSsrti077GIMC5/peVXqE6x/S0hvSKHZL5iNpTdas8q23w5zOWp16cps VhYOcT2h1n5viM1ice8/yWSIk/YhD2ZXeFBoibQky7ifRCBPInzB1bUbrNKY77a+ Zw0R7yjotE9OJLMSlk/IS5lOZtBDT3Gryk/Z2L/FTqlyepmi9ePrCQj7jCOt91pI ShKLh8JQAVhtEKFjlg3ziKvz7R5cjx5w8RRKST6Ro7H8m7rt0dfA+8w+XwLGPJQ/ 21v6U0wvUSnv/ehqYW4MP2ANZs81B2zC4i19BhkcpjC3nRKDu8ks3AutDvBNdi6s FQIDAQAB -----END PUBLIC KEY----- Remove the delimiters (encapsulation boundaries) used to demarcate the beginning and end of encoded data block in PEM format (applicable to both public and private keys) Delete the first and last line using sed tool $ sed \u0026#39;1d;$d\u0026#39; /tmp/id_rsa_2048_spki.pub.pem MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEArvcdS5hY0rxJnhGOsmRv lUBP3WFGcSsrti077GIMC5/peVXqE6x/S0hvSKHZL5iNpTdas8q23w5zOWp16cps VhYOcT2h1n5viM1ice8/yWSIk/YhD2ZXeFBoibQky7ifRCBPInzB1bUbrNKY77a+ Zw0R7yjotE9OJLMSlk/IS5lOZtBDT3Gryk/Z2L/FTqlyepmi9ePrCQj7jCOt91pI ShKLh8JQAVhtEKFjlg3ziKvz7R5cjx5w8RRKST6Ro7H8m7rt0dfA+8w+XwLGPJQ/ 21v6U0wvUSnv/ehqYW4MP2ANZs81B2zC4i19BhkcpjC3nRKDu8ks3AutDvBNdi6s FQIDAQAB Decode the base64 encoded text using base64 tool and save the output in a file (contents will be binary) $ sed \u0026#39;1d;$d\u0026#39; /tmp/id_rsa_2048_spki.pub.pem | base64 -d \u0026gt; /tmp/id_rsa_2048_spki.pub.decoded $ file /tmp/id_rsa_2048_spki.pub.decoded /tmp/id_rsa_2048_spki.pub.decoded: data Display the contents of file in hex using hexdump or xxd $ cat /tmp/id_rsa_2048_spki.pub.decoded | hexdump -e \u0026#39;24/1 \u0026#34;%.2x \u0026#34; \u0026#34;\\n\u0026#34;\u0026#39; 30 82 01 22 30 0d 06 09 2a 86 48 86 f7 0d 01 01 01 05 00 03 82 01 0f 00 30 82 01 0a 02 82 01 01 00 ae f7 1d 4b 98 58 d2 bc 49 9e 11 8e b2 64 6f 95 40 4f dd 61 46 71 2b 2b b6 2d 3b ec 62 0c 0b 9f e9 79 55 ea 13 ac 7f 4b 48 6f 48 a1 d9 2f 98 8d a5 37 5a b3 ca b6 df 0e 73 39 6a 75 e9 ca 6c 56 16 0e 71 3d a1 d6 7e 6f 88 cd 62 71 ef 3f c9 64 88 93 f6 21 0f 66 57 78 50 68 89 b4 24 cb b8 9f 44 20 4f 22 7c c1 d5 b5 1b ac d2 98 ef b6 be 67 0d 11 ef 28 e8 b4 4f 4e 24 b3 12 96 4f c8 4b 99 4e 66 d0 43 4f 71 ab ca 4f d9 d8 bf c5 4e a9 72 7a 99 a2 f5 e3 eb 09 08 fb 8c 23 ad f7 5a 48 4a 12 8b 87 c2 50 01 58 6d 10 a1 63 96 0d f3 88 ab f3 ed 1e 5c 8f 1e 70 f1 14 4a 49 3e 91 a3 b1 fc 9b ba ed d1 d7 c0 fb cc 3e 5f 02 c6 3c 94 3f db 5b fa 53 4c 2f 51 29 ef fd e8 6a 61 6e 0c 3f 60 0d 66 cf 35 07 6c c2 e2 2d 7d 06 19 1c a6 30 b7 9d 12 83 bb c9 2c dc 0b ad 0e f0 4d 76 2e ac 15 02 03 01 00 01 The sequence of bytes in hex are now ready to be analyzed Part 4 - Examining a SubjectPublicKeyInfo format RSA Public key in PEM format Unwrap a SubjectPublicKeyInfo format RSA public key to display the contents in hex $ grep \u0026#34;BEGIN\\|END\u0026#34; /tmp/id_rsa_2048_pkcs8.pub.pem -----BEGIN PUBLIC KEY----- -----END PUBLIC KEY----- $ sed \u0026#39;1d;$d\u0026#39; /tmp/id_rsa_2048_pkcs8.pub.pem | base64 -d | hexdump -ve \u0026#39;24/1 \u0026#34;%.2x \u0026#34; \u0026#34;\\n\u0026#34;\u0026#39; 30 82 01 22 30 0d 06 09 2a 86 48 86 f7 0d 01 01 01 05 00 03 82 01 0f 00 30 82 01 0a 02 82 01 01 00 ae f7 1d 4b 98 58 d2 bc 49 9e 11 8e b2 64 6f 95 40 4f dd 61 46 71 2b 2b b6 2d 3b ec 62 0c 0b 9f e9 79 55 ea 13 ac 7f 4b 48 6f 48 a1 d9 2f 98 8d a5 37 5a b3 ca b6 df 0e 73 39 6a 75 e9 ca 6c 56 16 0e 71 3d a1 d6 7e 6f 88 cd 62 71 ef 3f c9 64 88 93 f6 21 0f 66 57 78 50 68 89 b4 24 cb b8 9f 44 20 4f 22 7c c1 d5 b5 1b ac d2 98 ef b6 be 67 0d 11 ef 28 e8 b4 4f 4e 24 b3 12 96 4f c8 4b 99 4e 66 d0 43 4f 71 ab ca 4f d9 d8 bf c5 4e a9 72 7a 99 a2 f5 e3 eb 09 08 fb 8c 23 ad f7 5a 48 4a 12 8b 87 c2 50 01 58 6d 10 a1 63 96 0d f3 88 ab f3 ed 1e 5c 8f 1e 70 f1 14 4a 49 3e 91 a3 b1 fc 9b ba ed d1 d7 c0 fb cc 3e 5f 02 c6 3c 94 3f db 5b fa 53 4c 2f 51 29 ef fd e8 6a 61 6e 0c 3f 60 0d 66 cf 35 07 6c c2 e2 2d 7d 06 19 1c a6 30 b7 9d 12 83 bb c9 2c dc 0b ad 0e f0 4d 76 2e ac 15 02 03 01 00 01 30 82 01 22 0x30 is the tag value for a SEQUENCE. SubjectPublicKeyInfo is a SEQUENCE 0x82 is the length. However, since the high bit (bit 7) is set (0x1000 0010), it indicates that the length can be found in the next 7 bits (2). Next 2 bytes indicate the length of SEQUENCE as 0x0122 (290 bytes) The bytes following 0x0122 are the contents of SEQUENCE 30 0d 0x30 is the tag value for a SEQUENCE. AlgorithmIdentifier is a SEQUENCE 0x0d is the length. Since the high bit (bit 7) is not set (0x0000 1101), it indicates that the length is 0x0d (13 bytes) The 13 bytes following 0x0d are the contents of SEQUENCE (AlgorithmIdentifier) 06 09 0x06 is the tag value for an OBJECT IDENTIFIER. algorithm is an OBJECT IDENTIFIER type primitive 0x09 is the length. Since the high bit (bit 7) is not set (0x0000 1001), it indicates that the length is 0x09 (9 bytes) The 9 bytes following 0x09 are the contents of OBJECT IDENTIFIER (algorithm) 2a 86 48 86 f7 0d 01 01 01 Object identifier for RSA key is 1.2.840.113549.1.1.1 The first two components are processed in a special way in DER encoding. If x.y are the first two components, they are encoded as 40x + y in hex. So, in our case, 1.2 would be encoded as 42 = 40x1 + 2 which is 0x2A in hex. Subsequent bytes are represented using Variable Length Quantity (VLQ), also called base 128. Encoding 840 840 cannot be represented using short form (single byte) since the value is greater than 127 Represent the value in binary notation: 0b 0000 0011 0100 1000 Break it up in groups of 7 bits starting from the lowest significant bit (0b 0000110 1001000). This is equivalent to representing the number in base 128. Take the lowest 7 bits, and that gives you the least significant byte (0100 1000). This byte comes last. Add a 0 bit as highest bit for last octet since the last octet should indicate the end of value For all the other groups of 7 bits, set the MSb to 1. These added bits denote whether there is another byte to follow or not. Thus, by definition, the very last byte of a variable-length integer will have 0 as its MSb. By this definition our encoding will look like 0b 1000 0110 0100 1000 which can be represented in hex as 86 48 Encoding 113549 Represent the value in binary notation: 0b 0001 1011 1011 1000 1101 Break it up in groups of 7 bits starting from the lowest significant bit (0b 0000110 1110111 0001101) Take the lowest 7 bits, and that gives you the least significant byte (0b0000 1101) represented in hex as 0x0D For all the other groups of 7 bits, set the MSb to 1. Our encoding will now look like 0b 1000 0110 1111 0111 which can be represented in hex as 0x86f7 Combining them, we get 113549 represented as 86 f7 0d Encoding 1.1.1 These components can be encoded in short-form (1 byte) and hence they are encoded as 01 01 01 05 00 0x05 is the tag value for a NULL. parameters is NULL 0x00 indicates 0 length for parameters So, there are no parameters 03 82 01 0f 00 0x03 is the tag value of a BIT STRING. The DER encoded RSAPublicKey is the value of the BIT STRING (Reference). 0x82 is the length. However, since the high bit (bit 7) is set (0x1000 0010), it indicates that the length can be found in the next 7 bits (2). Next 2 bytes indicate the length of BIT STRING to be 0x010f (271 bytes) The bytes following 0x010f are the contents of BIT STRING (SEQUENCE of RSAPublicKey) In DER primitive encoding of BIT STRING, the first contents octet gives the number of bits by which the length of the bit string is less than the next multiple of eight.If the length of the bit string is a multiple of eight already, no padding is done. Since this BIT STRING does not have any padding, the padding count is 0x00. (Reference) 30 82 01 0a 0x30 is the tag value for a SEQUENCE. RSAPublicKey is a SEQUENCE 0x82 is the length. However, since the high bit (bit 7) is set (0x1000 0010), it indicates that the length can be found in the next 7 bits (2). Next 2 bytes indicate the length of SEQUENCE to be 0x010a (266 bytes) The bytes following 0x010a are the contents of SEQUENCE 02 82 01 01 0x02 is the tag value of an INTEGER. modulus is an INTEGER 0x82 is the length. Since the high bit (bit 7) is set (0x1000 0010), it indicates that the length can be found in the next 7 bits (next 2 bytes). So, 0x0101 (257 bytes) is the length of INTEGER 256 bytes are used for 2048 bit modulus and 1 byte is used as a sign byte (0 indicates positive integer) 257 bytes following 0x0101 represent the public modulus 00 ae f7 1d 4b 98 58 d2 bc 49 9e 11 8e b2 64 6f 95 40 4f dd 61 46 71 2b 2b b6 2d 3b ec 62 0c 0b 9f e9 79 55 ea 13 ac 7f 4b 48 6f 48 a1 d9 2f 98 8d a5 37 5a b3 ca b6 df 0e 73 39 6a 75 e9 ca 6c 56 16 0e 71 3d a1 d6 7e 6f 88 cd 62 71 ef 3f c9 64 88 93 f6 21 0f 66 57 78 50 68 89 b4 24 cb b8 9f 44 20 4f 22 7c c1 d5 b5 1b ac d2 98 ef b6 be 67 0d 11 ef 28 e8 b4 4f 4e 24 b3 12 96 4f c8 4b 99 4e 66 d0 43 4f 71 ab ca 4f d9 d8 bf c5 4e a9 72 7a 99 a2 f5 e3 eb 09 08 fb 8c 23 ad f7 5a 48 4a 12 8b 87 c2 50 01 58 6d 10 a1 63 96 0d f3 88 ab f3 ed 1e 5c 8f 1e 70 f1 14 4a 49 3e 91 a3 b1 fc 9b ba ed d1 d7 c0 fb cc 3e 5f 02 c6 3c 94 3f db 5b fa 53 4c 2f 51 29 ef fd e8 6a 61 6e 0c 3f 60 0d 66 cf 35 07 6c c2 e2 2d 7d 06 19 1c a6 30 b7 9d 12 83 bb c9 2c dc 0b ad 0e f0 4d 76 2e ac 15 Value of public modulus represented in 257 bytes 02 03 0x02 is the tag value of an INTEGER. publicexponent is an INTEGER 0x03 (3 bytes) is the length of this integer 3 bytes following 0x03 represent the public exponent 01 00 01 Value of public exponent (65537) Value of n and e can be confirmed using openssl rsa command $ openssl rsa -in id_rsa_2048_pkcs8.pub.pem -pubin -noout -text Public-Key: (2048 bit) Modulus: 00:ae:f7:1d:4b:98:58:d2:bc:49:9e:11:8e:b2:64: 6f:95:40:4f:dd:61:46:71:2b:2b:b6:2d:3b:ec:62: 0c:0b:9f:e9:79:55:ea:13:ac:7f:4b:48:6f:48:a1: d9:2f:98:8d:a5:37:5a:b3:ca:b6:df:0e:73:39:6a: 75:e9:ca:6c:56:16:0e:71:3d:a1:d6:7e:6f:88:cd: 62:71:ef:3f:c9:64:88:93:f6:21:0f:66:57:78:50: 68:89:b4:24:cb:b8:9f:44:20:4f:22:7c:c1:d5:b5: 1b:ac:d2:98:ef:b6:be:67:0d:11:ef:28:e8:b4:4f: 4e:24:b3:12:96:4f:c8:4b:99:4e:66:d0:43:4f:71: ab:ca:4f:d9:d8:bf:c5:4e:a9:72:7a:99:a2:f5:e3: eb:09:08:fb:8c:23:ad:f7:5a:48:4a:12:8b:87:c2: 50:01:58:6d:10:a1:63:96:0d:f3:88:ab:f3:ed:1e: 5c:8f:1e:70:f1:14:4a:49:3e:91:a3:b1:fc:9b:ba: ed:d1:d7:c0:fb:cc:3e:5f:02:c6:3c:94:3f:db:5b: fa:53:4c:2f:51:29:ef:fd:e8:6a:61:6e:0c:3f:60: 0d:66:cf:35:07:6c:c2:e2:2d:7d:06:19:1c:a6:30: b7:9d:12:83:bb:c9:2c:dc:0b:ad:0e:f0:4d:76:2e: ac:15 Exponent: 65537 (0x10001) References RFC 5280 - SubjectPublicKeyInfo (NOTE: Scroll down until \u0026ldquo;SubjectPublicKeyInfo ::\u0026rdquo;) RFC 3279 - What is subjectPublicKey BIT STRING? OpenSSL 1.0.2 - openssl-rsa OpenSSL 1.0.2 - openssl-asn1parse Wiki: ASN.1 Wiki: Length octets encoding forms Wiki: Identifier octets ASN.1 Javascript decoder tool Explained: Variable length quantity ","permalink":"https://partbypart.github.io/posts/deep-dive-subjectpublickeyinfo-rsa-public-key/","summary":"Dissect and explore an RSA public key in SubjectPublicKeyInfo PEM format","title":"Deep dive - Anatomy of a SubjectPublicKeyInfo RSA public key"},{"content":"Prerequisites Linux/MacOS openssl command line tool (version 1.0.2 or higher) RSA key components 101 - ASN.1, DER, PEM, PKCS#1, PKCS#8 Quick bytes - Basics of Distinguished Encoding Rules Part 1 - ASN.1 syntax to store RSA private key in PKCS#8 format RSA Private key syntax. (Additional reference: AlgorithmIdentifier syntax) PrivateKeyInfo ::= SEQUENCE { version Version, privateKeyAlgorithm AlgorithmIdentifier {{PrivateKeyAlgorithms}}, privateKey PrivateKey, -- \u0026#34;RSAPrivateKey\u0026#34; for an RSA private key attributes [0] Attributes OPTIONAL } Version ::= INTEGER {v1(0)} (v1,...) PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier AlgorithmIdentifier ::= SEQUENCE { algorithm OBJECT IDENTIFIER, parameters ANY DEFINED BY algorithm OPTIONAL } PrivateKey ::= OCTET STRING -- \u0026#34;RSAPrivateKey\u0026#34; for an RSA private key Attributes ::= SET OF Attributes For an RSA private key, the contents of PrivateKey are a BER encoding of a value of type RSAPrivateKey (Reference). Here\u0026rsquo;s the ASN.1 syntax for RSAPrivateKey as specified by RFC8017 RSAPrivateKey ::= SEQUENCE { version Version, modulus INTEGER, -- n publicExponent INTEGER, -- e privateExponent INTEGER, -- d prime1 INTEGER, -- p prime2 INTEGER, -- q exponent1 INTEGER, -- d mod (p-1) exponent2 INTEGER, -- d mod (q-1) coefficient INTEGER, -- (inverse of q) mod p otherPrimeInfos OtherPrimeInfos OPTIONAL } openssl genrsa and openssl genpkey command in OpenSSL 3 (or higher) generate RSA private key in PKCS #8 format by default. openssl genrsa in OpenSSL 1.0.2 generates RSA private key in PKCS#1 format by default. openssl pkcs8 can be used in OpenSSL 1.0.2 to convert RSA private key in PKCS#1 to PKCS#8 format Verify PKCS #8 RSA private key syntax $ openssl version -v OpenSSL 1.0.2s 28 May 2019 # Create a sample 2048 bit RSA private key (PKCS #1 by default) $ openssl genrsa -out /tmp/id_rsa_2048_pkcs1.pem 2048 $ grep \u0026#34;BEGIN\\|END\u0026#34; /tmp/id_rsa_2048_pkcs1.pem -----BEGIN RSA PRIVATE KEY----- -----END RSA PRIVATE KEY----- # Read a traditional format private key and write a PKCS#8 format key $ openssl pkcs8 -topk8 -in /tmp/id_rsa_2048_pkcs1.pem -nocrypt -out /tmp/id_rsa_2048_pkcs8.pem $ grep \u0026#34;BEGIN\\|END\u0026#34; /tmp/id_rsa_2048_pkcs8.pem -----BEGIN PRIVATE KEY----- -----END PRIVATE KEY----- $ openssl asn1parse -in /tmp/id_rsa_2048_pkcs8.pem -i 0:d=0 hl=4 l=1213 cons: SEQUENCE 4:d=1 hl=2 l= 1 prim: INTEGER :00 7:d=1 hl=2 l= 13 cons: SEQUENCE 9:d=2 hl=2 l= 9 prim: OBJECT :rsaEncryption 20:d=2 hl=2 l= 0 prim: NULL 22:d=1 hl=4 l=1191 prim: OCTET STRING [HEX DUMP]:3082...E155 # Drill into the OCTET STRING at offset 22 $ openssl asn1parse -in /tmp/id_rsa_2048_pkcs8.pem -i -strparse 22 0:d=0 hl=4 l=1187 cons: SEQUENCE 4:d=1 hl=2 l= 1 prim: INTEGER :00 7:d=1 hl=4 l= 257 prim: INTEGER :DE95...E8D7 268:d=1 hl=2 l= 3 prim: INTEGER :010001 273:d=1 hl=4 l= 256 prim: INTEGER :0799...41F1 533:d=1 hl=3 l= 129 prim: INTEGER :F967...AE4F 665:d=1 hl=3 l= 129 prim: INTEGER :E478...42F9 797:d=1 hl=3 l= 128 prim: INTEGER :72A7...7BA1 928:d=1 hl=3 l= 129 prim: INTEGER :B1B5...2701 1060:d=1 hl=3 l= 128 prim: INTEGER :47D8...E155 Part 2 - Commonly used tag values Tag (hex) Type 0x02 INTEGER 0x03 BIT STRING 0x04 OCTET STRING 0x05 NULL 0x06 OBJECT IDENTIFIER 0x0C UTF8String 0x10 (0x30*) SEQUENCE and SEQUENCE OF 0x11 (0x31*) SET and SET OF * The two tags marked with a * are always encoded as 0x30 or 0x31, because bit 6 is used to indicate whether a field is Constructed vs Primitive. These tags are always Constructed, so their encoding has bit 6 set to 1.\nHere is the complete list of Identifier octets for tags used in DER Part 3 - Steps to dissect a private key generated by openssl Lets use a sample 2048 bit PKCS #8 RSA private key as an example.\n$ cat /tmp/id_rsa_2048_pkcs8.pem -----BEGIN PRIVATE KEY----- MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDelT9ocLmSYOiW ... /bMIZw/LIEnLGWi7aCbR4VU= -----END PRIVATE KEY----- Remove the delimiters (encapsulation boundaries) used to demarcate the beginning and end of encoded data block in PEM format (applicable to both public and private keys) Delete the first and last line using sed tool $ sed \u0026#39;1d;$d\u0026#39; /tmp/id_rsa_2048_pkcs8.pem MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDelT9ocLmSYOiW ... /bMIZw/LIEnLGWi7aCbR4VU= Decode the base64 encoded text using base64 tool and save the output in a file (contents will be binary) $ sed \u0026#39;1d;$d\u0026#39; /tmp/id_rsa_2048_pkcs8.pem | base64 -d \u0026gt; /tmp/id_rsa_2048_pkcs8.decoded $ file /tmp/id_rsa_2048_pkcs8.decoded /tmp/id_rsa_2048_pkcs8.decoded: data Display the contents of file in hex using hexdump or xxd $ cat /tmp/id_rsa_2048_pkcs8.decoded | hexdump -e \u0026#39;30/1 \u0026#34;%.2x \u0026#34; \u0026#34;\\n\u0026#34;\u0026#39; 30 82 04 bd 02 01 00 30 0d 06 09 2a 86 48 86 f7 0d 01 01 01 05 00 04 82 04 a7 30 82 04 a3 02 01 00 02 82 01 01 00 de 95 3f 68 70 b9 92 60 e8 96 e4 bc 72 16 15 54 20 5a 1e df 42 24 1f ba 6f a1 52 97 ab 1b fb a2 78 4b e3 1a a3 ba 0c d1 27 4f bd 89 45 fa 54 fc 46 ab 02 bc ... ae de 5e f2 5a 64 3c 58 33 c6 2a 83 bf da d4 d8 f2 64 e4 62 87 87 34 f8 26 2c 33 1d ac d4 fd b3 08 67 0f cb 20 49 cb 19 68 bb 68 26 d1 e1 55 The sequence of bytes in hex are now ready to be analyzed Part 4 - Examining a PKCS #8 RSA private key in PEM format .Unwrap a PKCS #8 RSA private key to display the contents in hex $ grep \u0026#34;BEGIN\\|END\u0026#34; /tmp/id_rsa_2048_pkcs8.pem -----BEGIN PRIVATE KEY----- -----END PRIVATE KEY----- $ sed \u0026#39;1d;$d\u0026#39; /tmp/id_rsa_2048_pkcs8.pem | base64 -d | hexdump -ve \u0026#39;30/1 \u0026#34;%.2x \u0026#34; \u0026#34;\\n\u0026#34;\u0026#39; 30 82 04 bd 02 01 00 30 0d 06 09 2a 86 48 86 f7 0d 01 01 01 05 00 04 82 04 a7 30 82 04 a3 02 01 00 02 82 01 01 00 de 95 3f 68 70 b9 92 60 e8 96 e4 bc 72 16 15 54 20 5a 1e df 42 24 1f ba 6f a1 52 97 ab 1b fb a2 78 4b e3 1a a3 ba 0c d1 27 4f bd 89 45 fa 54 fc 46 ab 02 bc 24 97 32 5f ae c1 62 41 e4 92 d5 77 60 6a 91 a9 6f 82 57 83 3a 84 1b 9d d1 10 5c 35 a6 1b 5c 94 cd 2c 2c 56 b5 cd 16 9e 86 fd 16 88 b2 eb a0 42 c8 76 bf 25 39 5a 71 ec e0 71 23 fa ab 96 21 e0 97 85 dd eb 62 5a 67 6f 4a d6 2e 0d a0 50 ca d7 01 0f 16 d0 31 1b f9 9e 0b 7b 40 4e 5c 2a b5 ad 23 36 fa ac 8b d4 9f 6e 80 a9 5e 73 6e 16 cf 9d 41 16 b7 79 8e 62 5d b5 54 42 36 5b 47 06 02 cc ab 43 29 d7 9b 4a 88 02 b4 bd 1f 41 57 d5 a8 cd 50 e1 59 2c 10 64 09 93 86 38 69 5c ff 68 81 63 4b e1 42 72 ac 28 a8 98 4d a3 83 d9 90 be fd 12 f9 6b d3 38 11 e8 fe ab 79 33 fc 77 cb 83 e1 a1 04 e6 a1 b8 f8 fa 41 cd 64 95 e8 d7 02 03 01 00 01 02 82 01 00 07 99 4f 9a 43 ca 22 14 31 49 67 19 50 af c7 eb 07 22 1f b4 e4 bc 91 c7 ee 3d b3 17 f2 10 85 e6 ec a8 d8 fb 68 0b 23 ce 14 2a 18 f4 38 31 93 77 fb c8 d8 05 a8 b7 bc b7 eb ee d0 36 24 14 f4 d2 b4 b5 c1 e2 e7 8d de 36 94 1a a4 7f 85 65 10 97 3b 7d ea 71 d4 74 f2 35 c4 6c 58 9d f1 49 6f dc e8 10 6e 12 06 67 32 9f c8 82 13 5e 03 7f 92 ee ad af c2 a5 85 a6 c3 b9 60 7f 36 d1 fd 41 df 0a 90 22 a0 ed 24 ce 98 3e 88 2b 6a ba 2d 46 d0 c2 82 03 44 83 26 47 8a 95 54 fe 6f e7 13 fd a5 34 dd 3e e3 f9 84 d0 40 81 42 19 c8 7f 83 7b 63 5e 6f 1b 86 31 f2 df ad 06 61 b6 6a c6 fa b2 dd 39 87 a3 fe 97 7b c9 86 59 52 f2 b5 3a e9 52 77 94 ed 95 b3 a8 ed 99 5e bb 03 4d dc 0a bb 1f c5 63 d1 0f ea 0b bb cc 98 cc fc 9b 66 87 f9 df 0d 0b b4 f7 5e fa 73 93 ba 30 f5 15 ac db ca d0 41 f1 02 81 81 00 f9 67 95 e8 54 e5 42 21 27 ca 87 aa ac 4a e3 92 f8 49 72 79 86 f3 5d 71 a6 28 9c d0 4b 73 b1 fa a0 87 83 cf 9a 17 6b 21 6c c2 66 7a 35 3b 37 5b 18 d9 1c 40 56 2a 31 94 63 b6 93 f9 ac 38 30 93 3d 5d c0 dd 63 81 0f 9e bc 7f a7 41 8f 50 90 a2 9c 9a 87 11 a5 82 b0 c4 c6 74 01 7e 02 21 5d f7 70 53 1e f8 f0 9f 64 01 61 b9 9e 4f 27 bc b5 44 fd c4 66 e4 66 e2 79 55 e6 4a dd 4e bb 0a ae 4f 02 81 81 00 e4 78 15 e7 b9 36 d2 a7 cd b6 42 77 bb 11 5f 9f c5 cd 56 e1 2f 2a c7 36 98 fd fd d2 76 aa 73 17 03 d2 7a f7 30 07 39 ae 72 b2 74 b6 cf 55 aa 19 80 ff 0d 82 c2 57 6e 55 fd 27 ee 91 05 be d0 61 fc 16 65 14 4a b7 c1 92 4e 25 08 74 22 a3 8c bb 59 d4 ad 78 d7 c9 77 86 71 1a db 87 c6 44 8e 0d 24 5d 81 d4 41 bd be 3b a1 55 c2 6b 83 41 fd d0 b3 2b cb 5a 7f 3d 76 51 b7 ec b4 59 e7 1e 42 f9 02 81 80 72 a7 5c 12 e2 74 42 62 5b 98 8f a5 b6 6e f7 0f a9 74 9a 5b a3 de 5d 26 d1 eb f9 ab 08 04 b7 dd 2f cf 1c 99 63 8d 40 82 ad 2c f1 4f 5d 09 4b f9 65 02 ea 29 e9 72 9c 38 4b 5e b3 c8 23 93 f1 40 bf 05 4a 94 7c 19 e8 c4 60 83 8e b0 64 e1 f4 9b cc c2 7d 35 6f 91 15 12 60 e9 13 86 8a 14 2c ce 83 a4 b2 a8 5e 75 e7 d3 7a c9 8a 2d 79 67 17 2e 10 3b 29 d1 f6 3a 46 ed 66 61 24 3b fd 60 7b a1 02 81 81 00 b1 b5 36 54 a7 9c 1c fe a8 e3 bb 8f a5 d2 3d ae e9 0c 6f 27 78 a8 ad 8b aa 34 e5 d9 6e b3 e6 11 60 c7 b7 1d ce 1d d0 a0 00 57 0e b1 a3 53 de 9b 37 db 2b 87 29 e3 17 cf 8a ba 24 b6 68 e1 a2 f4 94 40 57 1f 11 7f 1c f1 d0 16 be 1c 97 54 df 82 5a bd 32 b1 6c 27 28 f1 49 c8 ba 39 41 de d1 1f 27 ca 13 d2 25 d0 90 c7 91 16 43 c3 9c b5 17 d7 dd 85 93 07 31 31 7d 76 d2 b9 2b 0f 42 d6 27 01 02 81 80 47 d8 24 2a 1f 5f 12 68 83 5e 39 f5 42 f9 fb f9 5b 56 a7 bf bf d0 89 32 33 fc 59 bd fe df 0d 55 a4 28 7c 63 a5 7c 19 be fb fc 01 ea 93 1b 9b 8d da eb c9 34 17 79 6b fd c1 75 02 b7 f0 e5 72 57 88 d6 c0 d3 08 24 11 cc a4 2b a8 9c 64 fa 26 b7 e3 ae de 5e f2 5a 64 3c 58 33 c6 2a 83 bf da d4 d8 f2 64 e4 62 87 87 34 f8 26 2c 33 1d ac d4 fd b3 08 67 0f cb 20 49 cb 19 68 bb 68 26 d1 e1 55 . Here is the list of Identifier octets for tags used in DER 30 82 04 bd 0x30 is the tag value for a SEQUENCE. PrivateKeyInfo is a SEQUENCE 0x82 is the length. However, since the high bit (bit 7) is set (0x1000 0010), it indicates that the length can be found in the next 7 bits (2). Next 2 bytes indicate the length of SEQUENCE as 0x04bd (1213 bytes) The bytes following 0x04bd are the contents of SEQUENCE 02 01 00 0x02 is the tag value of an INTEGER 0x01 (1 byte) is the length of this integer 1 byte following 0x01 is 0x00 and that\u0026rsquo;s the version (0) 30 0d 0x30 is the tag value for a SEQUENCE. AlgorithmIdentifier is a SEQUENCE 0x0d is the length. Since the high bit (bit 7) is not set (0x0000 1101), it indicates that the length is 0x0d (13 bytes) The 13 bytes following 0x0d are the contents of SEQUENCE (AlgorithmIdentifier) 06 09 0x06 is the tag value for an OBJECT IDENTIFIER. algorithm is an OBJECT IDENTIFIER type primitive 0x09 is the length. Since the high bit (bit 7) is not set (0x0000 1001), it indicates that the length is 0x09 (9 bytes) The 9 bytes following 0x09 are the contents of OBJECT IDENTIFIER (algorithm) 2a 86 48 86 f7 0d 01 01 01 Object identifier for RSA private key is 1.2.840.113549.1.1.1 The first two components are processed in a special way in DER encoding. If x.y are the first two components, they are encoded as 40x + y in hex. So, in our case, 1.2 would be encoded as 42 = 40x1 + 2 which is 0x2A in hex. Subsequent bytes are represented using Variable Length Quantity (VLQ), also called base 128. Encoding 840 840 cannot be represented using short form (single byte) since the value is greater than 127 Represent the value in binary notation: 0b 0000 0011 0100 1000 Break it up in groups of 7 bits starting from the lowest significant bit (0b 0000110 1001000). This is equivalent to representing the number in base 128. Take the lowest 7 bits, and that gives you the least significant byte (0100 1000). This byte comes last. Add a 0 bit as highest bit for last octet since the last octet should indicate the end of value For all the other groups of 7 bits, set the MSb to 1. These added bits denote whether there is another byte to follow or not. Thus, by definition, the very last byte of a variable-length integer will have 0 as its MSb. By this definition our encoding will look like 0b 1000 0110 0100 1000 which can be represented in hex as 86 48 Encoding 113549 Represent the value in binary notation: 0b 0001 1011 1011 1000 1101 Break it up in groups of 7 bits starting from the lowest significant bit (0b 0000110 1110111 0001101) Take the lowest 7 bits, and that gives you the least significant byte (0b0000 1101) represented in hex as 0x0D For all the other groups of 7 bits, set the MSb to 1. Our encoding will now look like 0b 1000 0110 1111 0111 which can be represented in hex as 0x86f7 Combining them, we get 113549 represented as 86 f7 0d Encoding 1.1.1 These components can be encoded in short-form (1 byte) and hence they are encoded as 01 01 01 05 00 0x05 is the tag value for a NULL. parameters is NULL 0x00 indicates 0 length for parameters So, there are no parameters 04 82 04 a7 0x04 is the tag value of a OCTET STRING. The algorithm identifier dictates the format of PrivateKey. So, for this RSA example, the DER encoded RSAPrivateKey is the value of the OCTET STRING. 0x82 is the length. However, since the high bit (bit 7) is set (0x1000 0010), it indicates that the length can be found in the next 7 bits (2). Next 2 bytes indicate the length of OCTET STRING to be 0x04a7 (1191 bytes) The bytes following 0x04a7 are the contents of OCTET STRING (SEQUENCE of RSAPrivateKey) 30 82 04 a3 0x30 is the tag value for a SEQUENCE. RSAPrivateKey is a SEQUENCE 0x82 is the length. However, since the high bit (bit 7) is set (0x1000 0010), it indicates that the length can be found in the next 7 bits (2). Next 2 bytes indicate the length of SEQUENCE as 0x04a3 (1187 bytes) The bytes following 0x04a3 are the contents of SEQUENCE 02 01 00 0x02 is the tag value of an INTEGER 0x01 (1 byte) is the length of this integer 1 byte following 0x01 is 0x00 and that\u0026rsquo;s the version (0) 02 82 01 01 0x02 is the tag value of an INTEGER. modulus is an INTEGER 0x82 is the length. Since the high bit (bit 7) is set (0x1000 0010), it indicates that the length can be found in the next 7 bits (next 2 bytes). So, 0x0101 (257 bytes) is the length of INTEGER 256 bytes are used for 2048 bit modulus and 1 byte is used as a sign byte (0 indicates positive integer) 257 bytes following 0x0101 represent the public modulus 00 de 95 3f 68 70 b9 92 60 e8 96 e4 bc 72 16 15 54 20 5a 1e df 42 24 1f ba 6f a1 52 97 ab 1b fb a2 78 4b e3 1a a3 ba 0c d1 27 4f bd 89 45 fa 54 fc 46 ab 02 bc 24 97 32 5f ae c1 62 41 e4 92 d5 77 60 6a 91 a9 6f 82 57 83 3a 84 1b 9d d1 10 5c 35 a6 1b 5c 94 cd 2c 2c 56 b5 cd 16 9e 86 fd 16 88 b2 eb a0 42 c8 76 bf 25 39 5a 71 ec e0 71 23 fa ab 96 21 e0 97 85 dd eb 62 5a 67 6f 4a d6 2e 0d a0 50 ca d7 01 0f 16 d0 31 1b f9 9e 0b 7b 40 4e 5c 2a b5 ad 23 36 fa ac 8b d4 9f 6e 80 a9 5e 73 6e 16 cf 9d 41 16 b7 79 8e 62 5d b5 54 42 36 5b 47 06 02 cc ab 43 29 d7 9b 4a 88 02 b4 bd 1f 41 57 d5 a8 cd 50 e1 59 2c 10 64 09 93 86 38 69 5c ff 68 81 63 4b e1 42 72 ac 28 a8 98 4d a3 83 d9 90 be fd 12 f9 6b d3 38 11 e8 fe ab 79 33 fc 77 cb 83 e1 a1 04 e6 a1 b8 f8 fa 41 cd 64 95 e8 d7 Value of public modulus represented in 257 bytes 02 03 0x02 is the tag value of an INTEGER. publicexponent is an INTEGER 0x03 (3 bytes) is the length of this integer 3 bytes following 0x03 represent the public exponent 01 00 01 Value of public exponent (65537) 02 82 01 00 0x02 is the tag value of an INTEGER. privateExponent is an INTEGER 0x82 is the length. Since the high bit (bit 7) is set (0x1000 0010), it indicates that the length can be found in the next 7 bits (next 2 bytes). So, 0x0100 (256 bytes) is the length of privateExponent 256 bytes following 0x0100 represent the private exponent 07 99 4f 9a 43 ca 22 14 31 49 67 19 50 af c7 eb 07 22 1f b4 e4 bc 91 c7 ee 3d b3 17 f2 10 85 e6 ec a8 d8 fb 68 0b 23 ce 14 2a 18 f4 38 31 93 77 fb c8 d8 05 a8 b7 bc b7 eb ee d0 36 24 14 f4 d2 b4 b5 c1 e2 e7 8d de 36 94 1a a4 7f 85 65 10 97 3b 7d ea 71 d4 74 f2 35 c4 6c 58 9d f1 49 6f dc e8 10 6e 12 06 67 32 9f c8 82 13 5e 03 7f 92 ee ad af c2 a5 85 a6 c3 b9 60 7f 36 d1 fd 41 df 0a 90 22 a0 ed 24 ce 98 3e 88 2b 6a ba 2d 46 d0 c2 82 03 44 83 26 47 8a 95 54 fe 6f e7 13 fd a5 34 dd 3e e3 f9 84 d0 40 81 42 19 c8 7f 83 7b 63 5e 6f 1b 86 31 f2 df ad 06 61 b6 6a c6 fa b2 dd 39 87 a3 fe 97 7b c9 86 59 52 f2 b5 3a e9 52 77 94 ed 95 b3 a8 ed 99 5e bb 03 4d dc 0a bb 1f c5 63 d1 0f ea 0b bb cc 98 cc fc 9b 66 87 f9 df 0d 0b b4 f7 5e fa 73 93 ba 30 f5 15 ac db ca d0 41 f1 Value of private exponent represented in 256 bytes 02 81 81 0x02 is the tag value of an INTEGER (prime1) 0x81 is the length. However, since the high bit (bit 7) is set (0x1000 0001), it indicates that the length can be found in the next 7 bits (next 1 byte). So, 0x81 (129 bytes) is the length of INTEGER (prime1) 129 bytes following 0x81 represent the prime1 00 f9 67 95 e8 54 e5 42 21 27 ca 87 aa ac 4a e3 92 f8 49 72 79 86 f3 5d 71 a6 28 9c d0 4b 73 b1 fa a0 87 83 cf 9a 17 6b 21 6c c2 66 7a 35 3b 37 5b 18 d9 1c 40 56 2a 31 94 63 b6 93 f9 ac 38 30 93 3d 5d c0 dd 63 81 0f 9e bc 7f a7 41 8f 50 90 a2 9c 9a 87 11 a5 82 b0 c4 c6 74 01 7e 02 21 5d f7 70 53 1e f8 f0 9f 64 01 61 b9 9e 4f 27 bc b5 44 fd c4 66 e4 66 e2 79 55 e6 4a dd 4e bb 0a ae 4f Value of prime1 represented in 129 bytes 02 81 81 0x02 is the tag value of an INTEGER (prime2) 0x81 is the length. However, since the high bit (bit 7) is set (0x1000 0001), it indicates that the length can be found in the next 7 bits (next 1 byte). So, 0x81 (129 bytes) is the length of INTEGER (prime2) 129 bytes following 0x81 represent the prime2 00 e4 78 15 e7 b9 36 d2 a7 cd b6 42 77 bb 11 5f 9f c5 cd 56 e1 2f 2a c7 36 98 fd fd d2 76 aa 73 17 03 d2 7a f7 30 07 39 ae 72 b2 74 b6 cf 55 aa 19 80 ff 0d 82 c2 57 6e 55 fd 27 ee 91 05 be d0 61 fc 16 65 14 4a b7 c1 92 4e 25 08 74 22 a3 8c bb 59 d4 ad 78 d7 c9 77 86 71 1a db 87 c6 44 8e 0d 24 5d 81 d4 41 bd be 3b a1 55 c2 6b 83 41 fd d0 b3 2b cb 5a 7f 3d 76 51 b7 ec b4 59 e7 1e 42 f9 Value of prime2 represented in 129 bytes 02 81 80 0x02 is the tag value of an INTEGER (exponent1) 0x81 is the length. However, since the high bit (bit 7) is set (0x1000 0001), it indicates that the length can be found in the next 7 bits (next 1 byte). So, 0x80 (128 bytes) is the length of INTEGER (exponent1) 128 bytes following 0x80 represent exponent1 72 a7 5c 12 e2 74 42 62 5b 98 8f a5 b6 6e f7 0f a9 74 9a 5b a3 de 5d 26 d1 eb f9 ab 08 04 b7 dd 2f cf 1c 99 63 8d 40 82 ad 2c f1 4f 5d 09 4b f9 65 02 ea 29 e9 72 9c 38 4b 5e b3 c8 23 93 f1 40 bf 05 4a 94 7c 19 e8 c4 60 83 8e b0 64 e1 f4 9b cc c2 7d 35 6f 91 15 12 60 e9 13 86 8a 14 2c ce 83 a4 b2 a8 5e 75 e7 d3 7a c9 8a 2d 79 67 17 2e 10 3b 29 d1 f6 3a 46 ed 66 61 24 3b fd 60 7b a1 Value of exponent1 represented in 128 bytes 02 81 81 0x02 is the tag value of an INTEGER (exponent2) 0x81 is the length. However, since the high bit (bit 7) is set (0x1000 0001), it indicates that the length can be found in the next 7 bits (next 1 byte). So, 0x81 (129 bytes) is the length of INTEGER (exponent2) 129 bytes following 0x81 represent the exponent2 00 b1 b5 36 54 a7 9c 1c fe a8 e3 bb 8f a5 d2 3d ae e9 0c 6f 27 78 a8 ad 8b aa 34 e5 d9 6e b3 e6 11 60 c7 b7 1d ce 1d d0 a0 00 57 0e b1 a3 53 de 9b 37 db 2b 87 29 e3 17 cf 8a ba 24 b6 68 e1 a2 f4 94 40 57 1f 11 7f 1c f1 d0 16 be 1c 97 54 df 82 5a bd 32 b1 6c 27 28 f1 49 c8 ba 39 41 de d1 1f 27 ca 13 d2 25 d0 90 c7 91 16 43 c3 9c b5 17 d7 dd 85 93 07 31 31 7d 76 d2 b9 2b 0f 42 d6 27 01 Value of exponent2 represented in 129 bytes 02 81 80 0x02 is the tag value of an INTEGER (coefficient) 0x81 is the length. However, since the high bit (bit 7) is set (0x1000 0001), it indicates that the length can be found in the next 7 bits (next 1 byte). So, 0x80 (128 bytes) is the length of INTEGER (coefficient) 128 bytes following 0x80 represent coefficient 47 d8 24 2a 1f 5f 12 68 83 5e 39 f5 42 f9 fb f9 5b 56 a7 bf bf d0 89 32 33 fc 59 bd fe df 0d 55 a4 28 7c 63 a5 7c 19 be fb fc 01 ea 93 1b 9b 8d da eb c9 34 17 79 6b fd c1 75 02 b7 f0 e5 72 57 88 d6 c0 d3 08 24 11 cc a4 2b a8 9c 64 fa 26 b7 e3 ae de 5e f2 5a 64 3c 58 33 c6 2a 83 bf da d4 d8 f2 64 e4 62 87 87 34 f8 26 2c 33 1d ac d4 fd b3 08 67 0f cb 20 49 cb 19 68 bb 68 26 d1 e1 55 Value of coefficient represented in 128 bytes Values of RSA private key can be verified using openssl rsa command $ openssl rsa -in /tmp/id_rsa_2048_pkcs8.pem -noout -text Private-Key: (2048 bit, 2 primes) modulus: 00:de:95:3f:68:70:b9:92:60:e8:96:e4:bc:72:16: ... e8:d7 publicExponent: 65537 (0x10001) privateExponent: 07:99:4f:9a:43:ca:22:14:31:49:67:19:50:af:c7: ...41:f1 prime1: 00:f9:67:95:e8:54:e5:42:21:27:ca:87:aa:ac:4a: ... 55:e6:4a:dd:4e:bb:0a:ae:4f prime2: 00:e4:78:15:e7:b9:36:d2:a7:cd:b6:42:77:bb:11: ... 51:b7:ec:b4:59:e7:1e:42:f9 exponent1: 72:a7:5c:12:e2:74:42:62:5b:98:8f:a5:b6:6e:f7: ... 66:61:24:3b:fd:60:7b:a1 exponent2: 00:b1:b5:36:54:a7:9c:1c:fe:a8:e3:bb:8f:a5:d2: ... 76:d2:b9:2b:0f:42:d6:27:01 coefficient: 47:d8:24:2a:1f:5f:12:68:83:5e:39:f5:42:f9:fb: ... 19:68:bb:68:26:d1:e1:55 References RFC 5208 - Private-Key Information Syntax OpenSSL 1.0.2 - openssl-genrsa OpenSSL 1.0.2 - openssl-asn1parse OpenSSL 1.0.2 - openssl-pkcs8 Wiki: PKCS #8 Wiki: ASN.1 Wiki: Length octets encoding forms Wiki: Identifier octets ASN.1 Javascript decoder tool Explained: Variable length quantity ","permalink":"https://partbypart.github.io/posts/deep-dive-pkcs8-rsa-private-key/","summary":"Dissect and explore a PKCS#8 RSA private key in PEM format","title":"Deep dive - Anatomy of a PKCS#8 RSA private key"},{"content":"Prerequisites Linux/MacOS openssl command line tool (version 3.x.x) Sign a file using openssl dgst $ ~/bin/openssl@3.0.8 version -v OpenSSL 3.0.8 7 Feb 2023 (Library: OpenSSL 3.0.8 7 Feb 2023) $ ~/bin/openssl@3.0.8 dgst -sha256 \\ -sign id_rsa.pem \\ -out 1GB-file.sig \\ ~/data/1GB-file $ du -b 1GB-file.sig 256\t1GB-file.sig Where,\ndgst: Command to create a digest. -\u0026lt;digest\u0026gt;: name of a supported digest. (Use openssl dgst -list for a list of supported digests) -sign \u0026lt;private_key\u0026gt; : Digitally sign the (calculated) digest using the given private key. -out \u0026lt;file_name\u0026gt;: File name to store the binary signature. \u0026lt;file_name\u0026gt;: File to digest and sign. Verify the signature of a file using openssl dgst openssl dgst can be used to verify digital signatures generated by openssl dgst or openssl pkeyutl. # Verify the signature generated using \u0026#34;openssl dgst\u0026#34; command $ ~/bin/openssl@3.0.8 dgst -sha256 \\ -verify id_rsa.pub.pem \\ -signature 1GB-file.sig \\ ~/data/1GB-file Verified OK Where,\ndgst: Command to create a digest. -\u0026lt;digest\u0026gt;: name of a supported digest. -verify \u0026lt;public_key\u0026gt; : Verify the signature using the given public key. -signature \u0026lt;file_name\u0026gt;: File containing the signature. \u0026lt;file_name\u0026gt;: Input file for verification. References Difference between openssl-dgst and openssl-pkeyutl OpenSSL 3 - openssl-dgst ","permalink":"https://partbypart.github.io/posts/quick-bytes-sign-verify-with-openssl/","summary":"Learn to sign and verify a file using openssl dgst command","title":"Quick bytes - Sign and verify a file using openssl-dgst"},{"content":"Prerequisites Linux/MacOS openssl command line tool (version 1.0.2 or higher) RSA key components 101 - ASN.1, DER, PEM, PKCS#1, PKCS#8 Quick bytes - Basics of Distinguished Encoding Rules Part 1 - ASN.1 syntax to store RSA public key in PKCS#1 format RSA Public key syntax RSAPublicKey ::= SEQUENCE { modulus INTEGER, -- n publicExponent INTEGER -- e } openssl genrsa command in OpenSSL 3 or higher generates public key with SubjectPublicKeyInfo syntax and private key in PKCS #8 PEM format by default. openssl genrsa command in OpenSSL 1.0.2 generates private key in PKCS #1 PEM format by default. openssl rsa command in OpenSSL 1.0.2 or higher can be used with -RSAPublicKey_out switch to generate an RSA public key in traditional PKCS #1 PEM format. Verifying PKCS #1 RSA public key syntax using openssl command $ openssl version -v OpenSSL 1.0.2s 28 May 2019 # Create a sample 2048 bit RSA private key $ openssl genrsa -out /tmp/id_rsa_2048_pkcs1.pem 2048 # Create the corresponding RSA public key in PKCS#1 format $ openssl rsa -in /tmp/id_rsa_2048_pkcs1.pem -RSAPublicKey_out -out /tmp/id_rsa_2048_pkcs1.pub.pem writing RSA key $ grep \u0026#34;BEGIN\\|END\u0026#34; /tmp/id_rsa_2048_pkcs1.pub.pem -----BEGIN RSA PUBLIC KEY----- -----END RSA PUBLIC KEY----- $ openssl asn1parse -in /tmp/id_rsa_2048_pkcs1.pub.pem -i 0:d=0 hl=4 l= 266 cons: SEQUENCE 4:d=1 hl=4 l= 257 prim: INTEGER :C9EE...4EB9 265:d=1 hl=2 l= 3 prim: INTEGER :010001 Part 2 - Commonly used tag values Tag (hex) Type 0x02 INTEGER 0x03 BIT STRING 0x04 OCTET STRING 0x05 NULL 0x06 OBJECT IDENTIFIER 0x0C UTF8String 0x10 (0x30*) SEQUENCE and SEQUENCE OF 0x11 (0x31*) SET and SET OF * The two tags marked with a * are always encoded as 0x30 or 0x31, because bit 6 is used to indicate whether a field is Constructed vs Primitive. These tags are always Constructed, so their encoding has bit 6 set to 1.\nHere is the complete list of Identifier octets for tags used in DER Part 3 - Steps to dissect a public key generated by openssl Lets use a sample 2048 bit PKCS #1 RSA public key as an example.\n$ cat /tmp/id_rsa_2048_pkcs1.pub.pem -----BEGIN RSA PUBLIC KEY----- MIIBCgKCAQEAye5UKudtq6hzoI9DH49a3HWCiz1/+rtIk4JuTdasR/8YrKNhiJv4 y6qR5YX2b05bbXBUAvAX35wLexG3fbJHzpimblLPV7OOfIfdvm/P34aiJXasH59l oSh5zxESnk1guxDfQFN8kdtp9Ss6QdR8JT57iJbLv0M1aECGaCCMp2fUUnc7bKXc utU9zj1N7lPcM6t5hV0/eTV37l0/dgL+bq1CJwZO+beBNqdABQcaJ11Sr900Z0wj 8GMuAextXZysiKf32ujxd7HgmRxFm+F2P5u0XKwPCgcx3oCD7q3qJ+2XXC2Z6bvO vD/Ulw7Q4gjaU2TE7+9DQUOFFxyj4XFOuQIDAQAB -----END RSA PUBLIC KEY----- Remove the delimiters (encapsulation boundaries) used to demarcate the beginning and end of encoded data block in PEM format (applicable to both public and private keys) Delete the first and last line using sed tool $ sed \u0026#39;1d;$d\u0026#39; /tmp/id_rsa_2048_pkcs1.pub.pem MIIBCgKCAQEAye5UKudtq6hzoI9DH49a3HWCiz1/+rtIk4JuTdasR/8YrKNhiJv4 y6qR5YX2b05bbXBUAvAX35wLexG3fbJHzpimblLPV7OOfIfdvm/P34aiJXasH59l oSh5zxESnk1guxDfQFN8kdtp9Ss6QdR8JT57iJbLv0M1aECGaCCMp2fUUnc7bKXc utU9zj1N7lPcM6t5hV0/eTV37l0/dgL+bq1CJwZO+beBNqdABQcaJ11Sr900Z0wj 8GMuAextXZysiKf32ujxd7HgmRxFm+F2P5u0XKwPCgcx3oCD7q3qJ+2XXC2Z6bvO vD/Ulw7Q4gjaU2TE7+9DQUOFFxyj4XFOuQIDAQAB Decode the base64 encoded text using base64 tool and save the output in a file (contents will be binary) $ sed \u0026#39;1d;$d\u0026#39; /tmp/id_rsa_2048_pkcs1.pub.pem | base64 -d \u0026gt; /tmp/id_rsa_2048_pkcs1.pub.decoded $ file /tmp/id_rsa_2048_pkcs1.pub.decoded /tmp/id_rsa_2048_pkcs1.pub.decoded: data Display the contents of file in hex using hexdump or xxd $ cat /tmp/id_rsa_2048_pkcs1.pub.decoded | hexdump -e \u0026#39;24/1 \u0026#34;%.2x \u0026#34; \u0026#34;\\n\u0026#34;\u0026#39; 30 82 01 0a 02 82 01 01 00 c9 ee 54 2a e7 6d ab a8 73 a0 8f 43 1f 8f 5a dc 75 82 8b 3d 7f fa bb 48 93 82 6e 4d d6 ac 47 ff 18 ac a3 61 88 9b f8 cb aa 91 e5 85 f6 6f 4e 5b 6d 70 54 02 f0 17 df 9c 0b 7b 11 b7 7d b2 47 ce 98 a6 6e 52 cf 57 b3 8e 7c 87 dd be 6f cf df 86 a2 25 76 ac 1f 9f 65 a1 28 79 cf 11 12 9e 4d 60 bb 10 df 40 53 7c 91 db 69 f5 2b 3a 41 d4 7c 25 3e 7b 88 96 cb bf 43 35 68 40 86 68 20 8c a7 67 d4 52 77 3b 6c a5 dc ba d5 3d ce 3d 4d ee 53 dc 33 ab 79 85 5d 3f 79 35 77 ee 5d 3f 76 02 fe 6e ad 42 27 06 4e f9 b7 81 36 a7 40 05 07 1a 27 5d 52 af dd 34 67 4c 23 f0 63 2e 01 ec 6d 5d 9c ac 88 a7 f7 da e8 f1 77 b1 e0 99 1c 45 9b e1 76 3f 9b b4 5c ac 0f 0a 07 31 de 80 83 ee ad ea 27 ed 97 5c 2d 99 e9 bb ce bc 3f d4 97 0e d0 e2 08 da 53 64 c4 ef ef 43 41 43 85 17 1c a3 e1 71 4e b9 02 03 01 00 01 The sequence of bytes in hex are now ready to be analyzed Part 4 - Examining a PKCS #1 RSA public key in PEM format Unwrap a PKCS #1 RSA public key to display the contents in hex $ grep \u0026#34;BEGIN\\|END\u0026#34; id_rsa_2048_pkcs1.pub.pem -----BEGIN RSA PUBLIC KEY----- -----END RSA PUBLIC KEY----- $ sed \u0026#39;1d;$d\u0026#39; id_rsa_2048_pkcs1.pub.pem | base64 -d | hexdump -ve \u0026#39;24/1 \u0026#34;%.2x \u0026#34; \u0026#34;\\n\u0026#34;\u0026#39; 30 82 01 0a 02 82 01 01 00 c9 ee 54 2a e7 6d ab a8 73 a0 8f 43 1f 8f 5a dc 75 82 8b 3d 7f fa bb 48 93 82 6e 4d d6 ac 47 ff 18 ac a3 61 88 9b f8 cb aa 91 e5 85 f6 6f 4e 5b 6d 70 54 02 f0 17 df 9c 0b 7b 11 b7 7d b2 47 ce 98 a6 6e 52 cf 57 b3 8e 7c 87 dd be 6f cf df 86 a2 25 76 ac 1f 9f 65 a1 28 79 cf 11 12 9e 4d 60 bb 10 df 40 53 7c 91 db 69 f5 2b 3a 41 d4 7c 25 3e 7b 88 96 cb bf 43 35 68 40 86 68 20 8c a7 67 d4 52 77 3b 6c a5 dc ba d5 3d ce 3d 4d ee 53 dc 33 ab 79 85 5d 3f 79 35 77 ee 5d 3f 76 02 fe 6e ad 42 27 06 4e f9 b7 81 36 a7 40 05 07 1a 27 5d 52 af dd 34 67 4c 23 f0 63 2e 01 ec 6d 5d 9c ac 88 a7 f7 da e8 f1 77 b1 e0 99 1c 45 9b e1 76 3f 9b b4 5c ac 0f 0a 07 31 de 80 83 ee ad ea 27 ed 97 5c 2d 99 e9 bb ce bc 3f d4 97 0e d0 e2 08 da 53 64 c4 ef ef 43 41 43 85 17 1c a3 e1 71 4e b9 02 03 01 00 01 Dissection of PKCS#1 RSA Public key DER encoding 30 82 01 0a 0x30 is the tag value for a SEQUENCE. RSAPublicKey is a SEQUENCE 0x82 is the length. However, since the high bit (bit 7) is set (0x1000 0010), it indicates that the length can be found in the next 7 bits (2). Next 2 bytes 0x010a (266 bytes) indicate the length of SEQUENCE These 266 bytes include TLV for n and TLV for e TLV for n: 1 (tag) + 3(length) + 1 (sign byte) + 256 (2048 bits of modulus) = 261 TLV for e: 1 (tag) + 1 (length) + 3 (Value of 65537 in hex is 0x010001) = 5 The bytes following 0x010a are the contents of SEQUENCE 02 82 01 01 0x02 is the tag value of an INTEGER. modulus is an INTEGER 0x82 is the length. However, since the high bit (bit 7) is set (0x1000 0010), it indicates that the length can be found in the next 7 bits (next 2 bytes). So, 0x0101 (257 bytes) is the length of INTEGER 256 bytes are used for 2048 bit modulus and 1 byte is used as a sign byte (0 indicates positive integer) 257 bytes following 0x0101 represent the public modulus 00 c9 ee 54 2a e7 6d ab a8 73 a0 8f 43 1f 8f 5a dc 75 82 8b 3d 7f fa bb 48 93 82 6e 4d d6 ac 47 ff 18 ac a3 61 88 9b f8 cb aa 91 e5 85 f6 6f 4e 5b 6d 70 54 02 f0 17 df 9c 0b 7b 11 b7 7d b2 47 ce 98 a6 6e 52 cf 57 b3 8e 7c 87 dd be 6f cf df 86 a2 25 76 ac 1f 9f 65 a1 28 79 cf 11 12 9e 4d 60 bb 10 df 40 53 7c 91 db 69 f5 2b 3a 41 d4 7c 25 3e 7b 88 96 cb bf 43 35 68 40 86 68 20 8c a7 67 d4 52 77 3b 6c a5 dc ba d5 3d ce 3d 4d ee 53 dc 33 ab 79 85 5d 3f 79 35 77 ee 5d 3f 76 02 fe 6e ad 42 27 06 4e f9 b7 81 36 a7 40 05 07 1a 27 5d 52 af dd 34 67 4c 23 f0 63 2e 01 ec 6d 5d 9c ac 88 a7 f7 da e8 f1 77 b1 e0 99 1c 45 9b e1 76 3f 9b b4 5c ac 0f 0a 07 31 de 80 83 ee ad ea 27 ed 97 5c 2d 99 e9 bb ce bc 3f d4 97 0e d0 e2 08 da 53 64 c4 ef ef 43 41 43 85 17 1c a3 e1 71 4e b9 Value of public modulus represented in 257 bytes 02 03 0x02 is the tag value of an INTEGER. publicexponent is an INTEGER 0x03 (3 bytes) is the length of this integer 3 bytes following 0x03 represent the public exponent 01 00 01 Value of public exponent (65537) Value of n and e can be confirmed using openssl rsa command $ openssl rsa -in id_rsa_pkcs1.pub.pem -pubin -noout -text Public-Key: (2048 bit) Modulus: 00:c9:ee:54:2a:e7:6d:ab:a8:73:a0:8f:43:1f:8f: 5a:dc:75:82:8b:3d:7f:fa:bb:48:93:82:6e:4d:d6: ac:47:ff:18:ac:a3:61:88:9b:f8:cb:aa:91:e5:85: f6:6f:4e:5b:6d:70:54:02:f0:17:df:9c:0b:7b:11: b7:7d:b2:47:ce:98:a6:6e:52:cf:57:b3:8e:7c:87: dd:be:6f:cf:df:86:a2:25:76:ac:1f:9f:65:a1:28: 79:cf:11:12:9e:4d:60:bb:10:df:40:53:7c:91:db: 69:f5:2b:3a:41:d4:7c:25:3e:7b:88:96:cb:bf:43: 35:68:40:86:68:20:8c:a7:67:d4:52:77:3b:6c:a5: dc:ba:d5:3d:ce:3d:4d:ee:53:dc:33:ab:79:85:5d: 3f:79:35:77:ee:5d:3f:76:02:fe:6e:ad:42:27:06: 4e:f9:b7:81:36:a7:40:05:07:1a:27:5d:52:af:dd: 34:67:4c:23:f0:63:2e:01:ec:6d:5d:9c:ac:88:a7: f7:da:e8:f1:77:b1:e0:99:1c:45:9b:e1:76:3f:9b: b4:5c:ac:0f:0a:07:31:de:80:83:ee:ad:ea:27:ed: 97:5c:2d:99:e9:bb:ce:bc:3f:d4:97:0e:d0:e2:08: da:53:64:c4:ef:ef:43:41:43:85:17:1c:a3:e1:71: 4e:b9 Exponent: 65537 (0x10001) References RFC8017 - RSA Public Key Syntax OpenSSL 1.0.2 - openssl-rsa OpenSSL 1.0.2 - openssl-asn1parse Wiki: PKCS #1 Wiki: ASN.1 Wiki: Length octets encoding forms Wiki: Identifier octets ASN.1 Javascript decoder tool ","permalink":"https://partbypart.github.io/posts/deep-dive-pkcs1-rsa-public-key/","summary":"Dissect and explore a PKCS#1 RSA public key in PEM format","title":"Deep dive - Anatomy of a PKCS#1 RSA public key"},{"content":" DER encoding uses a simple TLV (Type-Length-Value) binary encoding format that ensures consistent and unambiguous representation of data. Here\u0026rsquo;s a simplified TLV-encoded DER representation for the name \u0026ldquo;Mike\u0026rdquo; Type: Octet string - Tag value: 0x04 Length: 4 bytes - 0x04 Value: \u0026ldquo;Mike\u0026rdquo; - 0x4D 0x69 0x6B 0x65 (ASCII representation) Final encoding in hex 04 04 4D 69 6B 65 Verification using openssl $ openssl asn1parse -genstr \u0026#39;OCTETSTRING:Mike\u0026#39; -noout -out /tmp/sample.der $ hexdump -e \u0026#39;8/1 \u0026#34;%.2x \u0026#34; \u0026#34;\\n\u0026#34;\u0026#39; /tmp/sample.der 04 04 4d 69 6b 65 Tag values are followed by length. However, representing length of contents in a single byte (8 bits) allows us to specify a maximum of 127 bytes (MSB - Most Significant Bit is used for sign) . Hence, the encoding of length can take two forms: short or long. The short form is a single byte, used to specify a length between 0 and 127. The long form is at least two bytes long, and has bit 7 (Most significant bit - 8th bit) of the first byte set to 1. Bits 6-0 of the first byte indicate how many more bytes are in the length field itself. Then the remaining bytes specify the length itself, as a multi-byte integer. The longest possible length can be represented with 0b 1111 1110 (255 is reserved for future extensions), specifying that 126 (0b 111 1110)(bit 6-0) more bytes would follow in the length field alone. If each of those 126 bytes was 255, that would indicate 21008 -1 bytes (1008 = 126 bytes x 8 bits) to follow in the value field. That should be sufficient. The long form allows you to encode the same length multiple ways - for instance by using two bytes to express a length that could fit in one, or by using long form to express a length that could fit in the short form. However, DER rules state that smallest possible length representation should always be chosen. ","permalink":"https://partbypart.github.io/posts/quick-bytes-der-basics/","summary":"Brief and quick introduction to Distinguished Encoding rules","title":"Quick bytes - Basics of Distinguished Encoding Rules"},{"content":"Part 1 - ASN.1 Abstract Syntax Notation One (ASN.1) is a standard interface description language for defining data structures that can be serialized and deserialized in a cross-platform way. It is a notation used to describe the structure and encoding of data elements in a standardized way. Why do we need an interface description language (IDL)? Without an IDL, components in a distributed systems may not have a language-neutral way to define interfaces and data structures to communicate and speak the same language. An IDL allows components written in various languages to communicate seamlessly without being tightly coupled to a specific programming language\u0026rsquo;s syntax. Without an IDL, different software components or systems may not be able to agree on format of data and order of data transmission. An IDL helps achieve interoperability by providing a standardized description of these interfaces, ensuring that different systems can understand and communicate with each other consistently. Without an IDL, developers have to spend time and energy on low level network protocols. IDL creates separation of concerns that provides greater maintainability and flexibility. Without an IDL, there would be no easy way to keep track of interface versions due to updates. An IDL allows for versioning of interfaces and ensures backward compatibility by providing mechanisms to handle different versions of interfaces and gracefully migrate from one version to another. It provides a way to define the format of data in a platform-independent and language-independent manner, making it essential for protocols used in networking, cryptography, and data serialization. Where is ASN.1 used? X.509 Certificates Cryptography and Public Key Infrastructure (PKI) LDAP (Lightweight Directory Access Protocol) SNMP (Simple Network Management Protocol) ITU-T (International Telecommunication Union - Telecommunication Standardization Sector) and so on. In essence, ASN.1 plays a crucial role in defining data structures and encoding formats for a wide range of applications in telecommunications, networking, cryptography, and data serialization, enabling interoperability and standardized communication across different systems and technologies.\nWhat does ASN.1 look like? Imagine we want to represent the following information about a student: their name and age. Here\u0026rsquo;s how we can express this using ASN.1:\nStudentInfo ::= SEQUENCE { name UTF8String, age Age } Age ::= INTEGER (13..18) Where,\nStudentInfo is the name of our data structure, similar to a \u0026ldquo;class\u0026rdquo; or \u0026ldquo;type\u0026rdquo; or \u0026ldquo;struct\u0026rdquo; in programming. SEQUENCE indicates that the data structure contains a sequence of fields. name is a field of type UTF8String, which represents the student\u0026rsquo;s name using Unicode characters. age is a field of type Age, which represents the student\u0026rsquo;s age as another data structure called Age that represents a non-negative integer between 13 and 18. Verifying RSA public and private key ASN.1 syntax RSA public and private key syntax can be verified using openssl asn1parse command. It should match the syntax presented in the previous part.\nVerifying PKCS #1 RSA public key syntax $ grep \u0026#34;BEGIN\\|END\u0026#34; id_rsa_2048_pkcs1.pem.pub -----BEGIN RSA PUBLIC KEY----- -----END RSA PUBLIC KEY----- $ openssl asn1parse -in id_rsa_2048_pkcs1.pem.pub -i 0:d=0 hl=4 l= 266 cons: SEQUENCE 4:d=1 hl=4 l= 257 prim: INTEGER :AEF71D4B9858D2BC...EAC15 265:d=1 hl=2 l= 3 prim: INTEGER :010001 Verifying RSA public key SubjectPublicKeyInfo syntax $ openssl rsa -in id_rsa_2048_pkcs1.pem.pub -RSAPublicKey_in \\ -out id_rsa_2048_subjectpublickeyinfo.pem.pub writing RSA key $ grep \u0026#34;BEGIN\\|END\u0026#34; id_rsa_2048_subjectpublickeyinfo.pem.pub -----BEGIN PUBLIC KEY----- -----END PUBLIC KEY----- $ openssl asn1parse -in id_rsa_2048_subjectpublickeyinfo.pem.pub -i 0:d=0 hl=4 l= 290 cons: SEQUENCE 4:d=1 hl=2 l= 13 cons: SEQUENCE 6:d=2 hl=2 l= 9 prim: OBJECT :rsaEncryption 17:d=2 hl=2 l= 0 prim: NULL 19:d=1 hl=4 l= 271 prim: BIT STRING # Drill into the BIT STRING at offset 19 $ openssl asn1parse -in id_rsa_2048_subjectpublickeyinfo.pem.pub -i -strparse 19 0:d=0 hl=4 l= 266 cons: SEQUENCE 4:d=1 hl=4 l= 257 prim: INTEGER :AEF71D4B9858D2BC...EAC15 265:d=1 hl=2 l= 3 prim: INTEGER :010001 Verify PKCS #1 RSA private key syntax $ grep \u0026#34;BEGIN\\|END\u0026#34; id_rsa_2048_pkcs1.pem -----BEGIN RSA PRIVATE KEY----- -----END RSA PRIVATE KEY----- $ openssl asn1parse -in id_rsa_2048_pkcs1.pem -i 0:d=0 hl=4 l=1186 cons: SEQUENCE 4:d=1 hl=2 l= 1 prim: INTEGER :00 7:d=1 hl=4 l= 257 prim: INTEGER :AEF7...EAC15 268:d=1 hl=2 l= 3 prim: INTEGER :010001 273:d=1 hl=4 l= 256 prim: INTEGER :0B64...8E01 533:d=1 hl=3 l= 129 prim: INTEGER :B8DB...B321 665:d=1 hl=3 l= 129 prim: INTEGER :F24C...0E75 797:d=1 hl=3 l= 128 prim: INTEGER :78DA...A5C1 928:d=1 hl=3 l= 128 prim: INTEGER :516C...5D2D 1059:d=1 hl=3 l= 128 prim: INTEGER :4707...F154 Verify PKCS #8 RSA private key syntax $ openssl rsa -in id_rsa_2048_pkcs1.pem -out id_rsa_2048_pkcs8.pem writing RSA key $ grep \u0026#34;BEGIN\\|END\u0026#34; id_rsa_2048_pkcs8.pem -----BEGIN PRIVATE KEY----- -----END PRIVATE KEY----- $ openssl asn1parse -in id_rsa_2048_pkcs8.pem -i 0:d=0 hl=4 l=1212 cons: SEQUENCE 4:d=1 hl=2 l= 1 prim: INTEGER :00 7:d=1 hl=2 l= 13 cons: SEQUENCE 9:d=2 hl=2 l= 9 prim: OBJECT :rsaEncryption 20:d=2 hl=2 l= 0 prim: NULL 22:d=1 hl=4 l=1190 prim: OCTET STRING [HEX DUMP]:3082...F154 # Drill into the OCTET STRING at offset 22 $ openssl asn1parse -in id_rsa_2048_pkcs8.pem -i -strparse 22 0:d=0 hl=4 l=1186 cons: SEQUENCE 4:d=1 hl=2 l= 1 prim: INTEGER :00 7:d=1 hl=4 l= 257 prim: INTEGER :AEF7...EAC15 268:d=1 hl=2 l= 3 prim: INTEGER :010001 273:d=1 hl=4 l= 256 prim: INTEGER :0B64...8E01 533:d=1 hl=3 l= 129 prim: INTEGER :B8DB...B321 665:d=1 hl=3 l= 129 prim: INTEGER :F24C...0E75 797:d=1 hl=3 l= 128 prim: INTEGER :78DA...A5C1 928:d=1 hl=3 l= 128 prim: INTEGER :516C...5D2D 1059:d=1 hl=3 l= 128 prim: INTEGER :4707...F154 Part 2 - DER (Distinguished Encoding Rules) What is DER? It is a specific binary encoding format that ensures consistent and unambiguous representation of data. DER is a subset of BER (Basic Encoding Rules) providing for exactly one way to encode an ASN.1 value. For example, in BER a Boolean value of true can be encoded as any of 255 non-zero byte values, while in DER there is one way to encode a boolean value of true. Why do we need DER? ASN.1 is just a notation used to specify the structure of data elements and their types. It provides a high-level description of how data should be organized. However, ASN.1 itself doesn\u0026rsquo;t dictate a specific binary encoding format for representing this structured data. This is where DER plays a critical role. DER is a binary encoding format that is derived from ASN.1. It defines precise rules for encoding data elements specified in ASN.1 into a compact and unambiguous binary format. DER ensures that the encoded data can be uniquely decoded and interpreted by different systems, making it suitable for use in various applications like cryptography and network protocols. In summary, ASN.1 is a language for specifying data structures, while DER is a specific way of encoding data according to the rules defined by ASN.1. How does DER encode data? TLV (Tag-Length-Value) encoding is a fundamental mechanism in DER for representing and structuring data. The \u0026ldquo;Tag\u0026rdquo; identifies the data type, the \u0026ldquo;Length\u0026rdquo; specifies the size of the value in bytes, and the \u0026ldquo;Value\u0026rdquo; contains the actual data. TLV ensures a standardized, self-descriptive format that allows for unambiguous decoding and interoperability Example: Suppose we want to encode a message that includes a person\u0026rsquo;s name and a short message content. Here\u0026rsquo;s how the TLV structure might look in ASN.1 notation: Message ::= SEQUENCE { personName UTF8String, messageContent OCTET STRING } Message is a SEQUENCE type that groups two fields: personName (of type UTF8String - name in UTF-8 encoding) and messageContent (of type OCTET STRING - sequence of arbitrary bytes). Now, let\u0026rsquo;s encode the data \u0026ldquo;Alice\u0026rdquo; (person\u0026rsquo;s name) and \u0026ldquo;hello\u0026rdquo; (message content) using TLV encoding in DER personName: Tag for UTF8String is 0x0C Length of \u0026ldquo;Alice\u0026rdquo; is 5 (0x05) Value is the UTF-8 encoded representation of \u0026ldquo;Alice\u0026rdquo; TLV-encoded bytes for \u0026ldquo;Alice\u0026rdquo; (person\u0026rsquo;s name): 0C 05 41 6C 69 63 65\tmessageContent: Tag for OCTET STRING is 0x04 Length of \u0026ldquo;hello\u0026rdquo; is 5 (0x05) Value is the ASCII representation of \u0026ldquo;hello\u0026rdquo; TLV-encoded bytes for \u0026ldquo;hello\u0026rdquo; (message content): 04 05 68 65 6C 6C 6F Combine both TLV-encoded parts within the SEQUENCE: SEQUENCE has a tag value of 0x30 The length of the content (data elements within the SEQUENCE) is 0x0E (14 bytes). TLV Encoded bytes for the entire sequence 30 0E 0C 05 41 6C 69 63 65 04 05 68 65 6C 6C 6F Part 3 - PEM (Privacy Enhanced Mail) PEM (Privacy-Enhanced Mail) is a widely used encoding format that originated from the email encryption and security domain. It often uses headers like -----BEGIN CERTIFICATE----- and -----END CERTIFICATE----- to mark the boundaries of the encoded data, enabling easy storage, sharing, and transport of cryptographic information in a human-readable form. Encoded ASN.1 data, which is usually binary, is often PEM-encoded (base64 encoded with header and trailer text) so that it can be transmitted as textual data Example PEM format -----BEGIN PUBLIC KEY----- MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC0EZoftiJV5Cwka0/0JpqTbi0S hBvg4USO4ZggeoRTxRLBsAm6d2L2t11GgX59jPqRBIpJDykaTazLy+hMVT8Flc+m JO40zWiadmI4RKRILwnKhI///msR4pePenSkt4ZKftJtaBRMw3JQlP2bwrHcBHGq lbSTqtiZxRAvYRxM0wIDAQAB -----END PUBLIC KEY----- Part 4 - PKCS #1 (Public Key Cryptography Standards) A set of specifications published by RSA Laboratories that provides basic definitions and recommendations for implementing the RSA algorithm. Primarily focuses on specifications related to RSA cryptography, including key pair generation, encryption, decryption, digital signatures, and other RSA-related operations. An RSA public key in PKCS #1 should be represented with the ASN.1 type RSAPublicKey: RSAPublicKey ::= SEQUENCE { modulus INTEGER, -- n publicExponent INTEGER -- e } ``` Sample PKCS #1 RSA private key without password in PEM format -----BEGIN RSA PRIVATE KEY----- MIIBPAIBAAJBAKuwRVKZBqd/i0JpUGMdnqsw1fsXhvJMf7EBVdfEuSYcxniCTQO9 sEnrpBD6I7alMl9idAnIjwYe3qnJUNs6QLMCAwEAAQJAIIrKuPs0Xa85MB9SE1db 6crZ5DvzYh3J3j0IjltFVMmz8h6BjP43++QucRE+2UKQXuZMeVR7D2Y9AgW92/sE kQIhANpj1ggcraLCFPzg0X6uhIldOJbesGhOyNrkj6iAttC3AiEAyUGCB0CCPt2G j6soRoKjHsbrrhsfpQyg+vxbvycD2+UCIQCrYYmHGCpS/YfG4w7EIWQ1AAj2rI83 bAxHavIpw8izhQIhAJgq/7WcAN6ngGaAcyNdAxjyLqClwXd55P3gcT5GsZRBAiEA jcpo7KCOxpXbbo1Z69ak/t8nnS3xyrKw1YyE9y7L06s= -----END RSA PRIVATE KEY----- Part 5 - PKCS #8 One of the family of standards called Public-Key Cryptography Standards (PKCS) created by RSA Laboratories. Describes a standard syntax for storing private key information for private keys of RSA, DSA, ECDSA, and other algorithms. Allows private keys to be encrypted using various algorithms and encryption schemes, enhancing security. Private-key information shall have ASN.1 type PrivateKeyInfo: PrivateKeyInfo ::= SEQUENCE { version Version, privateKeyAlgorithm PrivateKeyAlgorithmIdentifier, privateKey PrivateKey, attributes [0] IMPLICIT Attributes OPTIONAL } Version ::= INTEGER PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier AlgorithmIdentifier ::= SEQUENCE { algorithm OBJECT IDENTIFIER, parameters ANY DEFINED BY algorithm OPTIONAL } PrivateKey ::= OCTET STRING Attributes ::= SET OF Attributes PrivateKey is an octet string whose contents are the value of the private key. The interpretation of the contents is defined in the registration of the private-key algorithm. For an RSA private key, for example, the contents are a BER encoding of a value of type RSAPrivateKey. Example: An RSA private key should be represented with the ASN.1 type RSAPrivateKey as specified in PKCS #1: RSAPrivateKey ::= SEQUENCE { version Version, modulus INTEGER, -- n publicExponent INTEGER, -- e privateExponent INTEGER, -- d prime1 INTEGER, -- p prime2 INTEGER, -- q exponent1 INTEGER, -- d mod (p-1) exponent2 INTEGER, -- d mod (q-1) coefficient INTEGER, -- (inverse of q) mod p otherPrimeInfos OtherPrimeInfos OPTIONAL } Sample PKCS #8 RSA private key without password in PEM format -----BEGIN PRIVATE KEY----- MIIBVgIBADANBgkqhkiG9w0BAQEFAASCAUAwggE8AgEAAkEAq7BFUpkGp3+LQmlQ Yx2eqzDV+xeG8kx/sQFV18S5JhzGeIJNA72wSeukEPojtqUyX2J0CciPBh7eqclQ 2zpAswIDAQABAkAgisq4+zRdrzkwH1ITV1vpytnkO/NiHcnePQiOW0VUybPyHoGM /jf75C5xET7ZQpBe5kx5VHsPZj0CBb3b+wSRAiEA2mPWCBytosIU/ODRfq6EiV04 lt6waE7I2uSPqIC20LcCIQDJQYIHQII+3YaPqyhGgqMexuuuGx+lDKD6/Fu/JwPb 5QIhAKthiYcYKlL9h8bjDsQhZDUACPasjzdsDEdq8inDyLOFAiEAmCr/tZwA3qeA ZoBzI10DGPIuoKXBd3nk/eBxPkaxlEECIQCNymjsoI7GldtujVnr1qT+3yedLfHK srDVjIT3LsvTqw== -----END PRIVATE KEY----- ","permalink":"https://partbypart.github.io/posts/demystifying-asn1-der-pem-pkcs1-pkcs8/","summary":"Learn the fundamentals of ASN.1, DER, PEM, PKCS#1 and PKCS#8","title":"Demystifying ASN.1, DER, PEM, PKCS1 and PKCS8"},{"content":"Prerequisites openssl command line tool (1.0.2 or higher) Part 1 - Components of an RSA public key Modulus (n) Public exponent (e) Part 2 - Components of an RSA private key Modulus (n) Public exponent (e) Private exponent prime1 prime2 exponent1 exponent2 coefficient Part 3 - View RSA key components using openssl View RSA public key components using openssl # Generate a 2048 bit RSA private key $ openssl genpkey -algorithm rsa -pkeyopt rsa_keygen_bits:2048 \\ -out id_rsa_2048.pem # Generate the corresponding RSA public key $ openssl rsa -in id_rsa_2048.pem -pubout -out id_rsa_2048.pub.pem $ openssl rsa -in id_rsa_2048.pub.pem -pubin -noout -text Public-Key: (2048 bit) Modulus: 00:de:95:3f:68:70:b9:92:60:e8:96:e4:bc:72:16: ... 77:cb:83:e1:a1:04:e6:a1:b8:f8:fa:41:cd:64:95: e8:d7 Exponent: 65537 (0x10001) View RSA private key components using openssl $ openssl rsa -in id_rsa_2048.pem -noout -text Private-Key: (2048 bit, 2 primes) modulus: 00:b7:f2:ac:46:82:1d:25:cc:62:b4:98:ab:69:a6: ff:11:40:a6:6e:57:6e:01:fa:7e:ee:8e:91:3a:67: ... 27:d1 publicExponent: 65537 (0x10001) privateExponent: 12:f6:9b:50:84:82:e5:3d:ea:12:14:a8:1d:32:f8: 5a:2a:b8:4d:a9:49:3f:be:77:7d:f7:e8:1c:65:89: ... prime1: 00:ba:d0:5d:f4:f4:98:24:08:d8:ba:a2:84:5a:39: 28:03:f4:f5:02:a7:2e:df:b4:6a:f8:3e:e6:ba:7f: ... prime2: 00:fc:12:95:8d:d3:f2:b8:e9:80:4f:d8:85:0e:33: 72:d2:74:40:ba:ca:2b:c5:c8:bb:86:6d:fa:07:5b: ... exponent1: 00:ba:5c:56:fe:a0:6a:8d:b8:0d:8c:d1:c7:3a:c2: 3d:fb:04:88:ce:e6:bc:ca:09:8f:94:aa:1b:3d:fd: ... exponent2: 15:f6:50:8d:70:df:fe:f8:69:33:8b:bb:dc:06:e3: 84:2e:98:cd:2d:7c:2e:d9:54:6d:5b:fb:a2:d4:82: ... coefficient: 12:7f:f6:85:e2:c3:23:e0:59:1d:a0:8b:e0:23:9c: ... 1e:7d:dc:26:d4:f0:9c:25 Additional notes RSA private keys generated by openssl can be represented either using PKCS #1 or PKCS #8 standards. Though they differ in their ASN.1 syntax and encoding, the internal components remain the same in both formats. RSA public keys generated by openssl can be represented either using PKCS #1 standard(RSAPublicKey) or SubjectPublicKeyInfo syntax. The internal components remain the same in both formats. References openssl-rsa openssl-genpkey ","permalink":"https://partbypart.github.io/posts/rsa-key-components/","summary":"Learn about the composition of RSA public and private keys and view the components using openssl command line tool","title":"RSA key components"},{"content":"Prerequisites openssl command line tool (version 3.x.x) A large file Linux/MacOS Part 1 - Encrypt/Decrypt a large file using a symmetric key derived from a password Encryption Encrypt a large (1GB) file using a password $ ~/bin/openssl@3.0.8 version -v OpenSSL 3.0.8 7 Feb 2023 (Library: OpenSSL 3.0.8 7 Feb 2023) $ ls -lhgG 1GB-file -rw-rw-r-- 1 1.0G Aug 23 05:57 1GB-file $ ~/bin/openssl@3.0.8 enc -aes-256-cbc -pbkdf2 -salt -md sha512 -in 1GB-file \\ -out 1GB-file.enc -pass pass:secretpassword $ ls -lhgG 1GB-file* -rw-rw-r-- 1 1.0G Aug 23 05:57 1GB-file -rw-rw-r-- 1 1.1G Aug 23 06:18 1GB-file.enc Where, enc: Encryption command. -aes-256-cbc: 256 bit AES (Advanced Encryption Standard) in CBC (Cipher block chaining) mode. -pbkdf2: Use PBKDF2 (Password Based Key Derivation Function) algorithm to derive a key from password. -salt: Use salt (randomly generated) when encrypting. (This is default) -md \u0026lt;digest\u0026gt;: Use the specified digest to create the key from the passphrase. The default algorithm is sha-256. -in \u0026lt;filename\u0026gt;: The input filename, standard input by default. (File to encrypt) -out \u0026lt;filename\u0026gt; : The output filename, standard output by default. (Encrypted file) -pass pass:\u0026lt;password\u0026gt;: Password used to derive a symmetric key. Decryption Decrypt an encrypted file using encryption password. $ ~/bin/openssl@3.0.8 enc -d -aes-256-cbc -pbkdf2 -md sha512 -in 1GB-file.enc \\ -out 1GB-file.dec -pass pass:secretpassword # Verify if the file was decrypted correctly by comparing the checksums $ sha256sum 1GB-file 1GB-file.dec e8a28381f00a8544bad85d1963622c7805d540ddeae35cdb70028f383b2482a3 1GB-file e8a28381f00a8544bad85d1963622c7805d540ddeae35cdb70028f383b2482a3 1GB-file.dec Where, enc: Encryption command. -d: Decrypt the input data. -aes-256-cbc: 256 bit AES in CBC mode. -pbkdf2: Use PBKDF2 algorithm to derive symmetric key using password. -md \u0026lt;digest\u0026gt;: Use the specified digest to create the key from the passphrase. The default algorithm is sha-256. (NOTE: This option has to be specified during decryption if a non-default digest was used during encryption) -in \u0026lt;filename\u0026gt;: The input filename, standard input by default. (Encrypted file) -out \u0026lt;filename\u0026gt; : The output filename, standard output by default. (Decrypted file) -pass pass:\u0026lt;password\u0026gt;: Password used to derive a symmetric key. Part 2 - Encrypt/Decrypt a large file using an asymmetric key pair Encrypting a large file using asymmetric (public-key) cryptography, is not the most efficient approach due to the limitations of asymmetric algorithms. Asymmetric encryption algorithms like RSA are computationally expensive, especially for large files. The encryption and decryption processes involve complex mathematical operations, making them slow and resource-intensive. Asymmetric encryption algorithms tend to produce ciphertext that is significantly larger than the original plaintext. This can lead to substantial increases in storage requirements and data transfer times. Asymmetric encryption keys need to be larger to provide the same level of security as symmetric encryption keys. Symmetric encryption is much faster and efficient for handling large data. In practice, a common approach is to use a hybrid encryption scheme: Generate a random symmetric encryption key and use a symmetric encryption algorithm (e.g., AES) to encrypt the large file. Encrypt the symmetric key using the recipient\u0026rsquo;s asymmetric (public) key. This step ensures that only the intended recipient with corresponding private key can decrypt the symmetric key. Send both the encrypted file (using symmetric encryption) and the encrypted symmetric key to the recipient. The recipient uses their private key to decrypt the symmetric key, and then uses the symmetric key to decrypt the actual file. This approach leverages the strengths of both asymmetric and symmetric encryption, resulting in both security and efficiency. Encryption using OpenSSL 3.0.8 Create random 32 (or any number) bytes of keying material using openssl. NOTE: These 32 bytes are not used as symmetric key.\n$ openssl rand 32 \u0026gt; keymaterial.bin $ xxd keymaterial.bin 00000000: f178 237d 5fbf 400e 0c7a 3c90 c0c2 6a22 .x#}_.@..z\u0026lt;...j\u0026#34; 00000010: d69a 182d ff57 97cd dfd6 2081 51c1 976d ...-.W.... .Q..m Where,\nrand: Generate random bytes. \u0026lt;number_of_random_bytes\u0026gt;: Required number of random bytes. Encrypt a large file using a 256 bit key derived from a random salt and keymaterial.bin\n$ ~/bin/openssl@3.0.8 enc -a -aes-256-cbc -in 1GB-file -out 1GB-file.enc \\ -pbkdf2 -salt -pass file:keymaterial.bin $ ls -lhgG 1GB-file* -rw-rw-r-- 1 1.0G Aug 23 05:57 1GB-file -rw-rw-r-- 1 1.4G Aug 23 06:48 1GB-file.enc Where,\nenc: Encryption command. -a: Base64 process the data. This means that if encryption is taking place the data is base64 encoded after encryption. -aes-256-cbc: 256 bit AES in CBC mode. -in \u0026lt;filename\u0026gt;: The input filename, standard input by default. (File to encrypt) -out \u0026lt;filename\u0026gt; : The output filename, standard output by default. (Encrypted file) -pbkdf2: Use PBKDF2 algorithm with a default iteration count of 10000 unless otherwise specified by the -iter command line option. -salt: Use salt (randomly generated) when encrypting. (This is default) -pass file:\u0026lt;key-material-file\u0026gt;: Bytes used to derive a 256 bit symmetric key. Encrypt the keymaterial.bin using receiver\u0026rsquo;s public key.\n$ openssl pkeyutl -encrypt -inkey id_rsa_2048.pub.pem -pubin -in keymaterial.bin \\ -out keymaterial.bin.enc # base64 encode the encrypted keymaterial for easy transmission $ openssl base64 -in keymaterial.bin.enc -out keymaterial.bin.enc.b64 Where,\npkeyutl: command used to perform low-level public key operations -encrypt: Encrypt the input data using a public key. -inkey \u0026lt;key\u0026gt;: The input key used for encryption. (NOTE: Use receiver\u0026rsquo;s public key) -pubin: The input file is a public key. -in \u0026lt;filename\u0026gt;: Input filename to read data from. -out \u0026lt;filename\u0026gt;: Output filename to write to. Send 1GB-file.enc and keymaterial.bin.enc.b64 to the receiver.\nDecryption using OpenSSL 3.0.8 Decode the encrypted key material $ openssl base64 -d -in keymaterial.bin.enc.b64 \\ -out keymaterial.bin.enc.decoded $ sha256sum keymaterial.bin.enc keymaterial.bin.enc.decoded 5c385055b8cfaec09c9c8d2f79e3f9cdfcf33a80f06d2a21592ac8652e228b61 keymaterial.bin.enc 5c385055b8cfaec09c9c8d2f79e3f9cdfcf33a80f06d2a21592ac8652e228b61 keymaterial.bin.enc.decoded Decrypt the keymaterial.bin.enc using receiver\u0026rsquo;s private key $ openssl pkeyutl -decrypt -inkey id_rsa_2048.pem \\ -in keymaterial.bin.enc.decoded -out keymaterial.bin.dec $ sha256sum keymaterial.bin keymaterial.bin.dec 0373f9536fa1a1e25527711bc53bccc1ce49970e1311c0602aa78b5115f5b251 keymaterial.bin 0373f9536fa1a1e25527711bc53bccc1ce49970e1311c0602aa78b5115f5b251 keymaterial.bin.dec Where, pkeyutl: command used to perform low-level public key operations -decrypt: Decrypt the input data using a private key. -inkey \u0026lt;key\u0026gt;: The input key used for decryption. (NOTE: Use receiver\u0026rsquo;s private key) -in \u0026lt;filename\u0026gt;: Input filename to read data from. -out \u0026lt;filename\u0026gt;: Output filename to write to. Decrypt the encrypted file by deriving the decryption key using keymaterial.bin $ ~/bin/openssl@3.0.8 enc -a -d -aes-256-cbc -in 1GB-file.enc \\ -out 1GB-file.dec -pbkdf2 -pass file:keymaterial.bin.dec # Verify if the file was decrypted correctly by comparing the checksums $ sha256sum 1GB-file 1GB-file.dec e8a28381f00a8544bad85d1963622c7805d540ddeae35cdb70028f383b2482a3 1GB-file e8a28381f00a8544bad85d1963622c7805d540ddeae35cdb70028f383b2482a3 1GB-file.dec Where, enc: Encryption command -a: Base64 process the data. If decryption is set then the input data is base64 decoded before being decrypted. -d: Decrypt the input data. -aes-256-cbc: 256 bit AES in CBC mode -in \u0026lt;filename\u0026gt;: The input filename, standard input by default. (Encrypted file) -out \u0026lt;filename\u0026gt; : The output filename, standard output by default. (Decrypted file) -pbkdf2: Use PBKDF2 algorithm with a default iteration count of 10000 unless otherwise specified by the -iter command line option. -pass file:\u0026lt;key-material-file\u0026gt;: Bytes used to derive a 256 bit symmetric key. That\u0026rsquo;s it. Without exchanging the symmetric key on wire or any means, sender and receiver were able to securely share a file using asymmetric cryptography. References OpenSSL 3 - openssl-enc OpenSSL 3 - openssl-rand OpenSSL 3 - openssl-pkutl ","permalink":"https://partbypart.github.io/posts/encrypt-decrypt-file-using-openssl-command/","summary":"Use openssl command line tool to encrypt/decrypt a file using a combination of asymmetric and symmetric key","title":"Encrypt/Decrypt a file using openssl command"},{"content":"Prerequisites openssl command line tool (version 1.0.2 or higher) Linux/MacOS Part 1 - RSA Private keys RSA Private key - PKCS #1 format $ openssl genrsa -traditional -out id_rsa_pkcs1.pem 2048 $ grep \u0026#34;BEGIN\\|END\u0026#34; id_rsa_pkcs1.pem -----BEGIN RSA PRIVATE KEY----- -----END RSA PRIVATE KEY----- RSA Private key - PKCS #8 format $ openssl genrsa -out id_rsa_pkcs8.pem 2048 $ grep \u0026#34;BEGIN\\|END\u0026#34; id_rsa_pkcs8.pem -----BEGIN PRIVATE KEY----- -----END PRIVATE KEY----- RSA Private key - OpenSSH format $ ssh-keygen -t rsa -b 1024 -N \u0026#34;\u0026#34; -f id_rsa_ssh.pem $ grep \u0026#34;BEGIN\\|END\u0026#34; id_rsa_ssh.pem -----BEGIN OPENSSH PRIVATE KEY----- -----END OPENSSH PRIVATE KEY----- Part 2 - RSA Public keys RSA Public key - PKCS #1 format # Generate a private key (any format) $ openssl genrsa -out id_rsa_pkcs8.pem 2048 $ openssl rsa -in id_rsa_pkcs8.pem -RSAPublicKey_out -out id_rsa_pkcs1.pub.pem writing RSA key $ grep \u0026#34;BEGIN\\|END\u0026#34; id_rsa_pkcs1.pub.pem -----BEGIN RSA PUBLIC KEY----- -----END RSA PUBLIC KEY----- RSA Public key - SubjectPublicKeyInfo format # Generate a private key (any format) $ openssl genrsa -out id_rsa_pkcs8.pem 2048 $ openssl rsa -in id_rsa_pkcs8.pem -out id_rsa_pkcs1.pub.pem $ grep \u0026#34;BEGIN\\|END\u0026#34; id_rsa_pkcs1.pub.pem -----BEGIN PUBLIC KEY----- -----END PUBLIC KEY----- RSA Public key - OpenSSH format $ ssh-keygen -t rsa -b 1024 -N \u0026#34;\u0026#34; -f id_rsa_ssh.pem $ cat id_rsa_ssh.pem.pub ssh-rsa AAAAB3NzaC1yc2EAAAAD... ","permalink":"https://partbypart.github.io/posts/rsa-key-formats/","summary":"Prerequisites openssl command line tool (version 1.0.2 or higher) Linux/MacOS Part 1 - RSA Private keys RSA Private key - PKCS #1 format $ openssl genrsa -traditional -out id_rsa_pkcs1.pem 2048 $ grep \u0026#34;BEGIN\\|END\u0026#34; id_rsa_pkcs1.pem -----BEGIN RSA PRIVATE KEY----- -----END RSA PRIVATE KEY----- RSA Private key - PKCS #8 format $ openssl genrsa -out id_rsa_pkcs8.pem 2048 $ grep \u0026#34;BEGIN\\|END\u0026#34; id_rsa_pkcs8.pem -----BEGIN PRIVATE KEY----- -----END PRIVATE KEY----- RSA Private key - OpenSSH format $ ssh-keygen -t rsa -b 1024 -N \u0026#34;\u0026#34; -f id_rsa_ssh.","title":"RSA Key formats"},{"content":"Prerequisites Linux/MacOS openssl command line tool (version 1.0.2 or higher) RSA key components 101 - ASN.1, DER, PEM, PKCS#1, PKCS#8 Quick bytes - Basics of Distinguished Encoding Rules Part 1 - ASN.1 syntax to store RSA private key in PKCS#1 format RSA Private key syntax RSAPrivateKey ::= SEQUENCE { version Version, modulus INTEGER, -- n publicExponent INTEGER, -- e privateExponent INTEGER, -- d prime1 INTEGER, -- p prime2 INTEGER, -- q exponent1 INTEGER, -- d mod (p-1) exponent2 INTEGER, -- d mod (q-1) coefficient INTEGER, -- (inverse of q) mod p otherPrimeInfos OtherPrimeInfos OPTIONAL } openssl genrsa command in OpenSSL 3 or higher generates private key in PKCS #8 PEM format by default. OpenSSL 3 -traditional switch can be used with openssl genrsa to generate private RSA key in traditional PKCS #1 format. openssl genrsa command in OpenSSL 1.0.2 generates private key in PKCS #1 PEM format by default. Verify PKCS #1 RSA private key syntax $ openssl version -v OpenSSL 1.0.2s 28 May 2019 # Create a sample 2048 bit RSA private key in PKCS#1 PEM format $ openssl genrsa -out /tmp/id_rsa_2048_pkcs1.pem 2048 2\u0026gt;1 /dev/null $ grep \u0026#34;BEGIN\\|END\u0026#34; /tmp/id_rsa_2048_pkcs1.pem -----BEGIN RSA PRIVATE KEY----- -----END RSA PRIVATE KEY----- $ openssl asn1parse -in /tmp/id_rsa_2048_pkcs1.pem -i 0:d=0 hl=4 l=1189 cons: SEQUENCE 4:d=1 hl=2 l= 1 prim: INTEGER :00 7:d=1 hl=4 l= 257 prim: INTEGER :D0F0...5E15 268:d=1 hl=2 l= 3 prim: INTEGER :010001 273:d=1 hl=4 l= 257 prim: INTEGER :C873...0AE5 534:d=1 hl=3 l= 129 prim: INTEGER :F7A5...792F 666:d=1 hl=3 l= 129 prim: INTEGER :D7FC...03FB 798:d=1 hl=3 l= 128 prim: INTEGER :40FD...4973 929:d=1 hl=3 l= 129 prim: INTEGER :9378...133F 1061:d=1 hl=3 l= 129 prim: INTEGER :F2BB...2AC7 Part 2 - Commonly used tag values Tag (hex) Type 0x02 INTEGER 0x03 BIT STRING 0x04 OCTET STRING 0x05 NULL 0x06 OBJECT IDENTIFIER 0x0C UTF8String 0x10 (0x30*) SEQUENCE and SEQUENCE OF 0x11 (0x31*) SET and SET OF * The two tags marked with a * are always encoded as 0x30 or 0x31, because bit 6 is used to indicate whether a field is Constructed vs Primitive. These tags are always Constructed, so their encoding has bit 6 set to 1.\nHere is the complete list of Identifier octets for tags used in DER Part 3 - Steps to dissect a private key generated by openssl Lets use a sample 2048 bit PKCS #1 RSA private key as an example.\n$ cat /tmp/id_rsa_2048_pkcs1.pem -----BEGIN RSA PRIVATE KEY----- MIIEpQIBAAKCAQEA0PAAi6cnOKQHuo/+hW0rBz/ffBa+nQjjkb/3Gpu1MOMXkxjA ... A7zn2iCt+hOBlwibgl6lVM0/kZCgbxoWYI7TJll3Prg6SOYEIG8xKsc= -----END RSA PRIVATE KEY----- Remove the delimiters (encapsulation boundaries) used to demarcate the beginning and end of encoded data block in PEM format (applicable to both public and private keys) Delete the first and last line using sed tool $ sed \u0026#39;1d;$d\u0026#39; /tmp/id_rsa_2048_pkcs1.pem MIIEpQIBAAKCAQEA0PAAi6cnOKQHuo/+hW0rBz/ffBa+nQjjkb/3Gpu1MOMXkxjA ... A7zn2iCt+hOBlwibgl6lVM0/kZCgbxoWYI7TJll3Prg6SOYEIG8xKsc= Decode the base64 encoded text using base64 tool and save the output in a file (contents will be binary) $ sed \u0026#39;1d;$d\u0026#39; /tmp/id_rsa_2048_pkcs1.pem | base64 -d \u0026gt; /tmp/id_rsa_2048_pkcs1.decoded $ file /tmp/id_rsa_2048_pkcs1.decoded /tmp/id_rsa_2048_pkcs1.decoded: DER Encoded Key Pair, 2048 bits Display the contents of file in hex using hexdump or xxd $ cat /tmp/id_rsa_2048_pkcs1.decoded | hexdump -e \u0026#39;24/1 \u0026#34;%.2x \u0026#34; \u0026#34;\\n\u0026#34;\u0026#39; 30 82 04 a5 02 01 00 02 82 01 01 00 d0 f0 00 8b a7 27 38 a4 07 ba 8f fe 85 6d 2b 07 3f df 7c 16 be 9d 08 e3 91 bf f7 1a 9b b5 30 e3 17 93 18 c0 ae 58 a6 a3 80 17 f7 e6 4d a1 11 d4 88 e0 22 8e 4e b6 cb 2c 8c e7 cb e9 ... 03 bc e7 da 20 ad fa 13 81 97 08 9b 82 5e a5 54 cd 3f 91 90 a0 6f 1a 16 60 8e d3 26 59 77 3e b8 3a 48 e6 04 20 6f 31 2a c7 The sequence of bytes in hex are now ready to be analyzed Part 4 - Examining a PKCS #1 RSA private key in PEM format Unwrap a PKCS #1 RSA private key to display the contents in hex $ grep \u0026#34;BEGIN\\|END\u0026#34; id_rsa_1024.pkcs1.pem -----BEGIN RSA PRIVATE KEY----- -----END RSA PRIVATE KEY----- $ sed \u0026#39;1d;$d\u0026#39; id_rsa_1024.pkcs1.pem | base64 -d | hexdump -ve \u0026#39;24/1 \u0026#34;%.2x \u0026#34; \u0026#34;\\n\u0026#34;\u0026#39; 30 82 02 5e 02 01 00 02 81 81 00 b4 11 9a 1f b6 22 55 e4 2c 24 6b 4f f4 26 9a 93 6e 2d 12 84 1b e0 e1 44 8e e1 98 20 7a 84 53 c5 12 c1 b0 09 ba 77 62 f6 b7 5d 46 81 7e 7d 8c fa 91 04 8a 49 0f 29 1a 4d ac cb cb e8 4c 55 3f 05 95 cf a6 24 ee 34 cd 68 9a 76 62 38 44 a4 48 2f 09 ca 84 8f ff fe 6b 11 e2 97 8f 7a 74 a4 b7 86 4a 7e d2 6d 68 14 4c c3 72 50 94 fd 9b c2 b1 dc 04 71 aa 95 b4 93 aa d8 99 c5 10 2f 61 1c 4c d3 02 03 01 00 01 02 81 81 00 a8 96 de 55 18 62 77 46 44 e9 e8 2b 18 6c d8 46 76 5d ee bb 0f 9a f1 6e 0d d4 3b 69 15 2c 35 7e 0a bc 9b 03 d0 b8 1c 48 df 8e 8e 07 89 95 24 dc 27 d0 37 64 85 b4 36 f3 48 78 1a 36 28 d9 9b 41 1d b3 7e 09 a0 a3 ff ce 0d 9d bb 48 50 47 6a e2 00 ae d3 97 2e d9 b1 3d 7d 02 77 ce 5a 10 e1 b8 f0 ca ee d4 ff 76 43 02 d5 1a 5d 13 98 50 58 d9 6d 31 19 00 11 5d 6a 46 f5 bb ed 85 01 44 5f a1 02 41 00 e3 a0 46 dc 04 89 34 d9 8c a8 f8 1f 66 5c 8b 16 65 47 9e 20 44 6b 7d 66 98 f4 e7 0b d7 97 df 8a 41 d9 1a 3e 28 16 3b d9 35 f6 b1 bc 30 2d f3 e5 0d c0 e0 57 2e 38 7e 55 88 2d 46 da 98 4f 63 31 02 41 00 ca 83 bc 09 27 b1 fe 82 79 1b 75 9c b4 d7 e8 3f 4a 8d 41 1b 1f 9d 5b c2 62 3b 01 61 17 8e 79 4b 32 d0 e2 e3 11 b3 7f c7 04 9c 33 0b 53 93 1a 09 7a c3 34 85 6a b1 52 80 8e 99 90 0f 64 cf 07 43 02 41 00 d8 52 fa e4 9f de f1 7e 0a c2 8e 43 f1 18 e4 0a 1d a8 89 6b 6a fa a8 8b 77 b3 cf 5c 1e c1 33 ed 86 14 d8 6e d7 d4 01 7e b5 5d 44 9e 6f 3f 4c b9 93 6f 89 04 f1 65 39 12 fa 3e e5 46 5b 57 9f 11 02 40 49 ae d6 aa aa 13 bc 1b 72 bf 07 f2 e5 65 ad 2d e2 0d 35 04 0e 63 ad b0 33 17 6e f0 09 a7 20 00 b9 53 81 49 c6 f5 fd 66 c7 09 a2 14 db ea a8 cd 8c 2a 1c 20 f2 e9 e3 af bc b2 a8 d4 c1 04 06 8b 02 41 00 ad c7 07 f6 86 26 fe 8c 1b 2a eb 50 b8 91 69 ac b7 33 28 a9 24 b2 cf a7 be 98 b4 b3 aa 1b 85 d6 4d 80 a0 09 d2 d7 6f 54 fb a2 a3 52 9e 68 f9 51 f2 13 f2 5e c3 71 79 d7 fc e3 df f8 89 93 dd 00 Dissection of PKCS#1 Private key DER encoding 30 82 02 5e 0x30 is the tag value for a SEQUENCE 0x82 is the length. However, since the high bit (bit 7) is set (0x1000 0010), it indicates that the length can be found in the next 7 bits (2). Next 2 bytes 0x025e (606 bytes) indicate the length of SEQUENCE The bytes following 0x025e are the contents of SEQUENCE 02 01 00 0x02 is the tag value of an INTEGER 0x01 (1 byte) is the length of this integer 1 byte following 0x01 is 0x00 and that\u0026rsquo;s the version (0) 02 81 81 0x02 is the tag value of an INTEGER 0x81 is the length. However, since the high bit (bit 7) is set (0x1000 0001), it indicates that the length can be found in the next 7 bits (next 1 byte). So, 0x81 (129 bytes) is the length of INTEGER 129 bytes following 0x81 represent the public modulus 00 b4 11 9a 1f b6 22 55 e4 2c 24 6b 4f f4 26 9a 93 6e 2d 12 84 1b e0 e1 44 8e e1 98 20 7a 84 53 c5 12 c1 b0 09 ba 77 62 f6 b7 5d 46 81 7e 7d 8c fa 91 04 8a 49 0f 29 1a 4d ac cb cb e8 4c 55 3f 05 95 cf a6 24 ee 34 cd 68 9a 76 62 38 44 a4 48 2f 09 ca 84 8f ff fe 6b 11 e2 97 8f 7a 74 a4 b7 86 4a 7e d2 6d 68 14 4c c3 72 50 94 fd 9b c2 b1 dc 04 71 aa 95 b4 93 aa d8 99 c5 10 2f 61 1c 4c d3 Value of public modulus represented in 129 bytes 02 03 0x02 is the tag value of an INTEGER 0x03 (3 bytes) is the length of this integer 3 bytes following 0x03 represent the public exponent 01 00 01 Value of public exponent (65537) 02 81 81 0x02 is the tag value of an INTEGER 0x81 is the length. However, since the high bit (bit 7) is set (0x1000 0001), it indicates that the length can be found in the next 7 bits (next 1 byte). So, 0x81 (129 bytes) is the length of INTEGER 129 bytes following 0x81 represent the private exponent 00 a8 96 de 55 18 62 77 46 44 e9 e8 2b 18 6c d8 46 76 5d ee bb 0f 9a f1 6e 0d d4 3b 69 15 2c 35 7e 0a bc 9b 03 d0 b8 1c 48 df 8e 8e 07 89 95 24 dc 27 d0 37 64 85 b4 36 f3 48 78 1a 36 28 d9 9b 41 1d b3 7e 09 a0 a3 ff ce 0d 9d bb 48 50 47 6a e2 00 ae d3 97 2e d9 b1 3d 7d 02 77 ce 5a 10 e1 b8 f0 ca ee d4 ff 76 43 02 d5 1a 5d 13 98 50 58 d9 6d 31 19 00 11 5d 6a 46 f5 bb ed 85 01 44 5f a1 Value of private exponent represented in 129 bytes 02 41 0x02 is the tag value of an INTEGER 0x41 (65 bytes) is the length of this integer 65 bytes following 0x41 represent prime1 00 e3 a0 46 dc 04 89 34 d9 8c a8 f8 1f 66 5c 8b 16 65 47 9e 20 44 6b 7d 66 98 f4 e7 0b d7 97 df 8a 41 d9 1a 3e 28 16 3b d9 35 f6 b1 bc 30 2d f3 e5 0d c0 e0 57 2e 38 7e 55 88 2d 46 da 98 4f 63 31 Value of prime1 represented in 65 bytes 02 41 0x02 is the tag value of an INTEGER 0x41 (65 bytes) is the length of this integer 65 bytes following 0x41 represent prime2 00 ca 83 bc 09 27 b1 fe 82 79 1b 75 9c b4 d7 e8 3f 4a 8d 41 1b 1f 9d 5b c2 62 3b 01 61 17 8e 79 4b 32 d0 e2 e3 11 b3 7f c7 04 9c 33 0b 53 93 1a 09 7a c3 34 85 6a b1 52 80 8e 99 90 0f 64 cf 07 43 Value of prime2 represented in 65 bytes 02 41 0x02 is the tag value of an INTEGER 0x41 (65 bytes) is the length of this integer 65 bytes following 0x41 represent exponent1 00 d8 52 fa e4 9f de f1 7e 0a c2 8e 43 f1 18 e4 0a 1d a8 89 6b 6a fa a8 8b 77 b3 cf 5c 1e c1 33 ed 86 14 d8 6e d7 d4 01 7e b5 5d 44 9e 6f 3f 4c b9 93 6f 89 04 f1 65 39 12 fa 3e e5 46 5b 57 9f 11 Value of exponent1 represented in 65 bytes 02 40 0x02 is the tag value of an INTEGER 0x40 (64 bytes) is the length of this integer 64 bytes following 0x41 represent exponent2 49 ae d6 aa aa 13 bc 1b 72 bf 07 f2 e5 65 ad 2d e2 0d 35 04 0e 63 ad b0 33 17 6e f0 09 a7 20 00 b9 53 81 49 c6 f5 fd 66 c7 09 a2 14 db ea a8 cd 8c 2a 1c 20 f2 e9 e3 af bc b2 a8 d4 c1 04 06 8b Value of exponent2 represented in 64 bytes 02 41 0x02 is the tag value of an INTEGER 0x41 (65 bytes) is the length of this integer 65 bytes following 0x41 represent coefficient 00 ad c7 07 f6 86 26 fe 8c 1b 2a eb 50 b8 91 69 ac b7 33 28 a9 24 b2 cf a7 be 98 b4 b3 aa 1b 85 d6 4d 80 a0 09 d2 d7 6f 54 fb a2 a3 52 9e 68 f9 51 f2 13 f2 5e c3 71 79 d7 fc e3 df f8 89 93 dd 00 Value of coefficient represented in 65 bytes References RFC 8017 - RSA Private Key Syntax OpenSSL 1.0.2 - openssl-genrsa OpenSSL 1.0.2 - openssl-asn1parse Wiki: PKCS #1 Wiki: ASN.1 Wiki: Length octets encoding forms Wiki: Identifier octets ASN.1 Javascript decoder tool ","permalink":"https://partbypart.github.io/posts/deep-dive-pkcs1-rsa-private-key/","summary":"Dissect and explore a PKCS#1 RSA private key in PEM format","title":"Deep dive - Anatomy of a PKCS#1 RSA private key"}]